// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    A Model for a current camera view of a place.
    These are preserved between visits to places.

    This is used to determine the movement properties.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Camera_Model = (function(superClass) {
    extend(Camera_Model, superClass);

    function Camera_Model() {
      this.center = new BDS.Point(0, 0);
      this.up = new BDS.Point(0, -1);
      this.angle = 0;
      this.interpolationFactor = .1;
    }

    Camera_Model.prototype.buildModel = function() {};

    Camera_Model.prototype.setCenter = function(pt) {
      return this.center = pt.clone();
    };

    Camera_Model.prototype.getCenter = function() {
      return this.center;
    };

    Camera_Model.prototype.setUpDirection = function(dir) {
      this.up = dir.normalize();
      return this.angle = Math.atan2(this.up.y, this.up.x) + Math.PI / 2;
    };

    Camera_Model.prototype.getUpDirection = function() {
      return this.up;
    };

    Camera_Model.prototype.setInterpolationFactor = function(per) {
      return this.interpolationFactor = per;
    };

    Camera_Model.prototype.getInterpolationFactor = function() {
      return this.interpolationFactor;
    };

    Camera_Model.prototype.applyToCamera = function(camera) {
      var current_angle, pos_old;
      pos_old = camera.position;
      camera.position.x = (1.0 - this.interpolationFactor) * pos_old.x + this.interpolationFactor * this.center.x;
      camera.position.y = (1.0 - this.interpolationFactor) * pos_old.y + this.interpolationFactor * this.center.y;
      current_angle = camera.rotation.z;
      while (this.angle > current_angle + Math.PI) {
        this.angle -= Math.PI * 2;
      }
      while (this.angle < current_angle - Math.PI) {
        this.angle += Math.PI * 2;
      }
      return camera.rotation.z = (1.0 - this.interpolationFactor) * camera.rotation.z + this.interpolationFactor * this.angle;
    };

    Camera_Model.prototype.applyInverseToObj = function(pivot, view, camera) {
      var angle, current_angle, pos_old;
      pos_old = view.position;
      view.position.x = (1.0 - this.interpolationFactor) * pos_old.x + this.interpolationFactor * (-this.center.x);
      view.position.y = (1.0 - this.interpolationFactor) * pos_old.y + this.interpolationFactor * (-this.center.y);
      pivot.position.x = camera.position.x;
      pivot.position.y = camera.position.y;

      /*
      obj.position.x = 600
      obj.position.y = 600
       */
      current_angle = pivot.rotation.z;
      angle = camera.rotation.z - this.angle;
      while (angle > current_angle + Math.PI) {
        angle -= Math.PI * 2;
      }
      while (angle < current_angle - Math.PI) {
        angle += Math.PI * 2;
      }
      return pivot.rotation.z = (1.0 - this.interpolationFactor) * pivot.rotation.z + this.interpolationFactor * angle;
    };

    return Camera_Model;

  })(BSS.Model);

}).call(this);
