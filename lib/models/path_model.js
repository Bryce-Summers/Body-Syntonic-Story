// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Path_Model = (function(superClass) {
    extend(Path_Model, superClass);

    function Path_Model() {
      this._capacity = 1;
      this._occupancy = 0;
      this._cost = 1;
      this._distance = 1;
      this.destination = null;
      this.last_agent = null;
      this.lane_left = null;
      this.lane_right = null;
      this.operators = [];
    }

    Path_Model.prototype.moveAgents = function(dt) {
      var agent, c, companions, j, k, l, lane, len, len1, len2, len3, m, navigation, next_path, oper, oper_index, path_model, per_end, per_operator, per_start, percentages_per_meter;
      agent = this.last_agent;
      percentages_per_meter = 1.0 / this._distance;
      while (agent !== null && agent.getNavigation().getCurrentLocation() === this) {
        if (agent.lookupKey("psychology") === "follow") {
          agent = agent.getNextAgent();
          continue;
        }
        per_start = agent.getPercentage();
        agent.moveAlongPath(dt, percentages_per_meter);
        per_end = agent.getPercentage();
        companions = agent.getAllCompanions();
        for (j = 0, len = companions.length; j < len; j++) {
          c = companions[j];
          c.setPercentage(per_end);
        }
        companions.push(agent);
        for (k = 0, len1 = companions.length; k < len1; k++) {
          c = companions[k];
          lane = c.getNavigation().getCurrentLocation();
          oper_index = lane.getNextOperatorIndex(per_start);
          if (oper_index !== null) {
            oper = lane.operators[oper_index];
            per_operator = oper.percentage;
            while (oper_index < lane.operators.length && oper.percentage <= per_end) {
              agent.operate(oper.operator);
              for (l = 0, len2 = companions.length; l < len2; l++) {
                c = companions[l];
                c.operate(oper.operator);
              }
              oper_index += 1;
              oper = lane.operators[oper_index];
            }
          }
        }
        if (per_end > 1.0) {
          for (m = 0, len3 = companions.length; m < len3; m++) {
            agent = companions[m];
            navigation = agent.getNavigation();
            path_model = navigation.getCurrentLocation();
            next_path = path_model.getDestination(agent);
            if (path_model.endsAtConditional()) {
              if (agent.lookupKey("psychology") !== "follow") {
                agent.setKey("psychology", "up");
              }
            }
            if (next_path !== null) {
              path_model.dequeueAgent(agent);
              next_path.enqueueAgent(agent);
              navigation.setCurrentLocation(next_path);

              /*
              Ideally we should move the agent through without a hitch, activating all operators along the way,
              includng the ones on the next path.
              dist = (per_end - 1.0) / percentages_per_meter
              per = dist / next_path.length...
               */
              agent.setPercentage(0.0);
            } else {
              agent.setPercentage(1.0);
            }
          }
        }
        agent = agent.getNextAgent();
      }
    };

    Path_Model.prototype.setCapacity = function(capacity) {
      return this._capacity = capacity;
    };

    Path_Model.prototype.setTransversalCost = function(cost) {
      return this._cost = cost;
    };

    Path_Model.prototype.setTransversalLength = function(length) {
      return this._distance = length;
    };

    Path_Model.prototype.setDestination = function(model) {
      return this.destination = model;
    };

    Path_Model.prototype.getDestination = function(agent_model) {
      if (this.endsAtConditional()) {
        return this.destination.getDestination(agent_model);
      }
      return this.destination;
    };

    Path_Model.prototype.endsAtConditional = function() {
      return this.destination instanceof BSS.Condition_Model;
    };

    Path_Model.prototype.getTransversalLength = function() {
      return this._distance;
    };

    Path_Model.prototype.isClear = function() {
      return this._occupancy === 0;
    };

    Path_Model.prototype.enqueueAgent = function(agent_model) {
      var navigation_model;
      navigation_model = agent_model.getNavigation();
      navigation_model.setCurrentLocation(this);
      agent_model.setNextAgent(this.last_agent);
      agent_model.getElement().reposition();
      return this.last_agent = agent_model;
    };

    Path_Model.prototype.dequeueAgent = function(agent_model) {};

    Path_Model.prototype.getNextOperatorIndex = function(percentage) {
      var lower_bound, oper;
      oper = {
        operator: null,
        percentage: percentage
      };
      lower_bound = BDS.Arrays.binarySearch(this.operators, oper, function(a, b) {
        return a.percentage <= b.percentage;
      });
      if (lower_bound >= this.operators.length - 1) {
        return null;
      }
      return lower_bound + 1;
    };

    Path_Model.prototype.addOperator = function(operator, percentage) {
      var i, insert_index, j, k, new_opers, oper, ref, ref1, ref2;
      oper = {
        operator: operator,
        percentage: percentage
      };
      insert_index = BDS.Arrays.binarySearch(this.operators, oper, function(a, b) {
        return a.percentage <= b.percentage;
      });
      new_opers = [];
      for (i = j = 0, ref = insert_index; j <= ref; i = j += 1) {
        new_opers.push(this.operators[i]);
      }
      new_opers.push(oper);
      for (i = k = ref1 = insert_index + 1, ref2 = this.operators.length; k < ref2; i = k += 1) {
        new_opers.push(this.operators[i]);
      }
      this.operators = new_opers;
    };

    Path_Model.prototype.setLeftLane = function(path) {
      if (this.lane_left !== null) {
        this.lane_left.lane_right = null;
      }
      this.lane_left = path;
      if (path !== null) {
        this.lane_left.lane_right = this;
      }
    };

    Path_Model.prototype.setRightLane = function(path) {
      if (this.lane_right !== null) {
        this.lane_right.lane_left = null;
      }
      this.lane_right = path;
      if (path !== null) {
        return this.lane_right.lane_left = this;
      }
    };

    Path_Model.prototype.getLeftLane = function() {
      return this.lane_left;
    };

    Path_Model.prototype.getRightLane = function() {
      return this.lane_right;
    };

    Path_Model.prototype.getAllLanes = function() {
      var out;
      out = this.getAllOtherLanes();
      out.push(this);
      return out;
    };

    Path_Model.prototype.getFarLeftLane = function() {
      var out;
      out = this;
      while (out.getLeftLane() !== null) {
        out = out.getLeftLane();
      }
      return out;
    };

    Path_Model.prototype.getFarRightLane = function() {
      var out;
      out = this;
      while (out.getRightLane() !== null) {
        out = out.getRightLane();
      }
      return out;
    };

    Path_Model.prototype.getAllOtherLanes = function() {
      var left, out, right;
      left = this.lane_left;
      right = this.lane_right;
      out = [];
      while (left !== null) {
        out.push(left);
        left = left.getLeftLane();
      }
      while (right !== null) {
        out.push(right);
        right = right.getRightLane();
      }
      return out;
    };

    Path_Model.prototype.getAllLanes = function() {
      var lane, out;
      out = [];
      lane = this.getFarLeftLane();
      while (lane !== null) {
        out.push(lane);
        lane = lane.getRightLane();
      }
      return out;
    };

    return Path_Model;

  })(BSS.Model);

}).call(this);
