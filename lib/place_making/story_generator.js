// Generated by CoffeeScript 1.11.1

/*

Story Generator.
Written by Bryce Summers on Mar.27.2018.
Purpose: Encodes all of the information necessary to generate a story block.

The content cooresponds to story NAME blocks in a story file.

Allows for new story block elements to be instantiated. Generates instances, but leaves management to other 

 * FIXME: Change last_path to last_element. (Path, conditional)
 * FIXME: Revert to old state list on fork return, because who knows what has happened.
 */

(function() {
  BSS.Story_Generator = (function() {
    function Story_Generator(tokens) {
      this.tokens = tokens;
    }

    Story_Generator.prototype.newState = function() {
      var state;
      state = {};
      state.path = null;
      state.normalized_path_length = 0;
      state.position = new BDS.Point(0, 0);
      state.rotation_angle = 0;
      state.output = [];
      state.forked_state = null;
      state.conditional_function = null;
      state.character = null;
      state.index = 0;
      return state;
    };

    Story_Generator.prototype.copyState = function(state_in) {
      var out;
      out = {};
      out.path = state_in.path;
      out.normalized_path_length = state_in.normalized_path_length;
      out.position = state_in.position.clone();
      out.rotation_angle = state_in.rotation_angle;
      out.output = state_in.output;
      out.forked_state = state_in.forked_state;
      out.conditional_function = state_in.conditional_function;
      out.index = state_in.index;
      out.character = null;
      return out;
    };

    Story_Generator.prototype.continuationCopy = function(states) {
      var j, len1, out, s, state;
      out = [];
      for (j = 0, len1 = states.length; j < len1; j++) {
        state = states[j];
        s = this.newState();
        s.path = state.path;
        s.position = state.position;
        s.rotation_angle = state.rotation_angle;
        s.index = state.index;
        out.push(s);
      }
      return out;
    };


    /*
    story MVP
    up 100
    narrate 1 The body is an accumulation of food.
    food 10
    food 20
    food 30
    food 40
    food 50
    food 60
    food 70
    food 80
    food 90
    the end
     */

    Story_Generator.prototype.generateElements = function(states_start) {
      var forked_state, i, j, k, l, len1, len2, m, out, pred, ref, ref1, state, state_index, states, token_list;
      states = [];
      for (j = 0, len1 = states_start.length; j < len1; j++) {
        state = states_start[j];
        states.push(this.copyState(state));
      }
      for (i = k = 0, ref = this.tokens.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        token_list = this.tokens[i];
        if (token_list[0] === "introduce") {
          states = this.generateAgent(token_list, states);
          continue;
        }
        if (token_list[0] === "tell") {
          this.generateTellOperators(states, token_list);
          continue;
        }
        for (state_index = l = 0, ref1 = states.length; 0 <= ref1 ? l < ref1 : l > ref1; state_index = 0 <= ref1 ? ++l : --l) {
          state = states[state_index];
          state.token_list = token_list;
          state.type = token_list[0];
          if (state.type === "up" || state.type === "arc") {
            this.generatePath(state);
          }

          /*
          if state.type == "introduce"
              @generateAgent(state)
           */
          pred = state.type === "narrate" || state.type === "say" || state.type === "think";
          pred = pred || (state.type === "food" || state.type === "good" || state.type === "bad");
          if (pred) {
            this.generateMessage(state);
          }
          if (state.type === "fork") {
            if (state.forked_state === null) {
              this.generateConditional(state);
              state.forked_state = this.copyState(state);
            } else {
              forked_state = state.forked_state;
              state = this.copyState(forked_state);
              state.forked_state = forked_state;
              states[state_index] = state;
            }
            state.conditional_function = this.generateAgentConditionalFunction(token_list.slice(1));
          }
        }

        /*
        @update
        
        @linkPathsAndAddCharacters
        for i in [0...states.length - 1]
            state1 = states[i]
            state2 = states[i + 1]
            path_model1 = state1.path.getModel()
            path_model2 = state2.path.getModel()
        
             * Bidirectional link!
            path_model1.setRightLane(path_model2)
         */
      }
      out = [];
      for (m = 0, len2 = states.length; m < len2; m++) {
        state = states[m];
        out = out.concat(state.output);
      }
      return out;
    };

    Story_Generator.prototype.generatePath = function(state) {
      var angle, conditional, cx, cy, dir, dx, dy, factor, func, i, j, len, length, path_element, path_pline, pt, pt0, pt1, pts, px, py, radians_turned, radius_of_path, ref;
      if (state.type === "up") {
        dx = Math.cos(state.rotation_angle);
        dy = Math.sin(state.rotation_angle);
        length = state.token_list[1] * EX.style.file_to_screen_distance_factor;
        state.normalized_path_length = state.token_list[1];
        pt0 = state.position.clone();
        dir = new BDS.Point(dx, dy);
        pt1 = pt0.add(dir.multScalar(length));
        path_pline = new BDS.Polyline(false, [pt0, pt1]);
        path_element = new BSS.Path_Element(path_pline);
        state.position = pt1;
        state.output.push(path_element);
      } else if (state.type === "arc") {
        factor = 1;
        if (state.token_list[1] === "right") {
          factor = -1;
        }
        dx = Math.cos(state.rotation_angle - factor * Math.PI / 2);
        dy = Math.sin(state.rotation_angle - factor * Math.PI / 2);
        radius_of_path = EX.style.path_curvature_inverse + factor * EX.style.radius_path_default * state.index;
        cx = state.position.x + dx * radius_of_path;
        cy = state.position.y + dy * radius_of_path;
        pts = [];
        len = 100;
        radians_turned = factor * state.token_list[2] * Math.PI / 180;
        state.normalized_path_length = state.token_list[2];
        for (i = j = 0, ref = len; j <= ref; i = j += 1) {
          angle = state.rotation_angle + factor * Math.PI / 2 - i * 1.0 / len * radians_turned;
          px = cx + Math.cos(angle) * radius_of_path;
          py = cy + Math.sin(angle) * radius_of_path;
          pt = new BDS.Point(px, py);
          pts.push(pt);
        }
        path_pline = new BDS.Polyline(false, pts);
        path_element = new BSS.Path_Element(path_pline);
        state.output.push(path_element);
        state.position = pts[pts.length - 1];
        state.rotation_angle -= radians_turned;
      }
      if (state.character !== null) {
        path_element.addAgent(state.character);
        state.character = null;
      }
      if (state.conditional_function) {
        conditional = state.path;
        func = state.conditional_function;
        conditional.getModel().associateCondition(func, path_element.getModel());
        state.conditional_function = null;
      } else if (state.path !== null) {
        state.path.getModel().setDestination(path_element.getModel());
      }
      state.path = path_element;
    };

    Story_Generator.prototype.generateAgent = function(token_list, states) {
      var agent, agent_model, focus_agent, func, j, len1, s, state, token_index;
      token_index = 1;
      agent = new BSS.Agent_Element();
      agent_model = agent.getModel();
      if (token_list[token_index] === "left") {
        token_index += 1;
        if (token_list[token_index] === "companion") {
          token_index += 1;
          state = states[0];
          func = function(a) {
            return function(agent_model) {
              return agent_model.setLeftCompanion(a);
            };
          };
          this.addOperatorToPath(func(agent_model), state.normalized_path_length, state);
        }
        state = this.constructLeftState(states[0]);
        states = [state].concat(states);
      } else if (token_list[token_index] === "right") {
        token_index += 1;
        if (token_list[token_index] === "companion") {
          token_index += 1;
          state = states[states.length - 1];
          func = function(a) {
            return function(agent_model) {
              return agent_model.setRightCompanion(a);
            };
          };
          this.addOperatorToPath(func(agent_model), state.normalized_path_length, state);
        }
        state = this.constructRightState(states[states.length - 1]);
        states.push(state);
      } else {
        if (states.length === 0) {
          states.push(this.newState());
        }
        for (j = 0, len1 = states.length; j < len1; j++) {
          s = states[j];
          if (s.index === 0) {
            state = s;
            break;
          }
        }
      }
      focus_agent = false;
      if (token_list[token_index] === "protagonist") {
        focus_agent = true;
        token_index += 1;
      }
      agent_model.setCharacterType(token_list[token_index], focus_agent);
      state.output.push(agent);
      state.character = agent;
      return states;
    };

    Story_Generator.prototype.constructRightState = function(state) {
      var lane_pos, loc, offset, out, path, ref, right, up;
      path = state.path;
      ref = path.getLocation(1.0), loc = ref[0], up = ref[1];
      right = new BDS.Point(-up.y, up.x);
      offset = path.getCrossSectionRadius();
      lane_pos = loc.add(right.multScalar(offset));
      out = this.newState();
      out.position = lane_pos;
      out.rotation_angle = state.rotation_angle;
      out.index = state.index + 1;
      return out;
    };

    Story_Generator.prototype.constructLeftState = function(state) {
      var lane_pos, left, loc, offset, out, path, ref, up;
      path = state.path;
      ref = path.getLocation(1.0), loc = ref[0], up = ref[1];
      left = new BDS.Point(up.y, -up.x);
      offset = path.getCrossSectionRadius();
      lane_pos = loc.add(left.multScalar(offset));
      out = this.newState();
      out.position = lane_pos;
      out.rotation_angle = state.rotation_angle;
      out.index = state.index - 1;
      return out;
    };

    Story_Generator.prototype.generateMessage = function(state) {
      var func, i, j, message, normalized_dist, ref, str;
      normalized_dist = state.token_list[1];
      message = "";
      for (i = j = 2, ref = state.token_list.length; j < ref; i = j += 1) {
        str = state.token_list[i];
        message = message + " " + str;
      }
      console.log(state.token_list[0]);
      func = function(agent_model) {
        return agent_model.statistics.setNarrative(message);
      };
      this.addOperatorToPath(func, normalized_dist, state, state.token_list[0]);
    };

    Story_Generator.prototype.generateOperator = function(state) {
      var func, normalized_dist, type;
      normalized_dist = state.token_list[1];
      type = false;
      if (state.token_list[0] === "food") {
        func = function(agent_model) {
          var food;
          food = agent_model.statistics.getFood();
          return agent_model.statistics.setFood(food + 1);
        };
        type = "food";
      }
      this.addOperatorToPath(func, normalized_dist, state, type);
    };

    Story_Generator.prototype.addOperatorToPath = function(func, normalized_distance, state, type) {
      var model, operator, percentage;
      percentage = normalized_distance / state.normalized_path_length;
      operator = new BSS.Operator_Element();
      operator.setFunction(func);
      state.path.addOperator(operator, percentage);
      state.output.push(operator);
      if (type) {
        model = operator.getModel();
        model.setType(type);
        operator.buildFromConfiguration();
      }
    };

    Story_Generator.prototype.generateTellOperators = function(states, token_list) {
      var continue_states, j, len1, model, operator, percentage, state;
      continue_states = this.continuationCopy(states);
      percentage = .99;
      for (j = 0, len1 = states.length; j < len1; j++) {
        state = states[j];
        operator = new BSS.Operator_Element();
        model = operator.getModel();
        model.setType("story_load");
        model.setState("story_name", token_list[1]);
        model.setState("states", continue_states);
        operator.buildFromConfiguration();
        state.path.addOperator(operator, percentage);
        state.output.push(operator);
      }
    };

    Story_Generator.prototype.generateConditional = function(state) {
      var conditional;
      conditional = new BSS.Condition_Element();
      state.path.getModel().setDestination(conditional.getModel());
      state.path = conditional;
      return state.output.push(conditional);
    };

    Story_Generator.prototype.generateAgentConditionalFunction = function(token_list) {
      return function(agent_model) {
        var val1, val2;
        val1 = agent_model.lookupKey(token_list[0]);
        val2 = token_list[2];
        while (val1 === "follow") {
          agent_model = agent_model.leader;
          val1 = agent_model.lookupKey(token_list[0]);
        }
        return val1 === val2;
      };
    };

    return Story_Generator;

  })();

}).call(this);
