// Generated by CoffeeScript 1.11.1

/*

Story loader class.

Written by Bryce Summers on Mar.27.2018.
Purpose: creates a named set of story generators from the given text file.
 */

(function() {
  BSS.Story_Loader = (function() {
    function Story_Loader(place) {
      this.place = place;
    }

    Story_Loader.prototype.load_story = function(file_name) {

      /*
      Read File.
      perform rest of the operations asynchronously when the file loads.
      place will be created then.
       */
      return this.readFile(file_name);
    };

    Story_Loader.prototype.readFile = function(file_name) {
      var rawFile;
      rawFile = new XMLHttpRequest();
      rawFile.open("GET", file_name, true);
      rawFile.storyLoader = this;
      rawFile.onreadystatechange = function() {
        var allText;
        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status === 0) {
            allText = rawFile.responseText;
            return this.storyLoader.createStories(allText);
          }
        }
      };
      rawFile.send(null);
    };


    /*
       Break lines.
       Break stories.
       Tokenize.
     */

    Story_Loader.prototype.createStories = function(text) {
      var block_end_indices, block_lines, block_start_indices, i, index, index_end, index_start, j, k, l, len1, line, lines, m, map, name, ref, ref1, ref2, ref3, removeEOL, start_name, storyGenerator;
      console.log(text);
      text = text.replace("\t", " ");
      lines = text.split("\n");
      removeEOL = false;
      for (j = 0, len1 = lines.length; j < len1; j++) {
        line = lines[j];
        if (line[0] === "the" && line[1] === "end") {
          removeEOL = false;
        }
      }
      block_start_indices = [];
      block_end_indices = [];
      for (i = k = 0, ref = lines.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        line = lines[i];
        line = line.split(" ");
        line = this.filter(line, "");
        if (removeEOL && i < lines.length - 1) {
          line = this.removeEOL(line);
        }
        if (line[0] === "story") {
          block_start_indices.push(i);
        }
        if (line[0] === "the" && line[1] === "end") {
          block_end_indices.push(i);
        }
        lines[i] = line;
      }
      if (block_start_indices.length !== block_end_indices.length) {
        throw new Error("Syntax error in start and ends of blocks.");
      }
      map = {};
      start_name = name = lines[0][1];
      for (i = l = 0, ref1 = block_start_indices.length; l < ref1; i = l += 1) {
        index_start = block_start_indices[i];
        index_end = block_end_indices[i];
        block_lines = [];
        for (index = m = ref2 = index_start, ref3 = index_end; m <= ref3; index = m += 1) {
          line = lines[index];
          block_lines.push(line);
        }
        storyGenerator = new BSS.Story_Generator(block_lines);
        name = block_lines[0][1];
        map[name] = storyGenerator;
        if (name === start_name) {
          map.start = storyGenerator;
        }
      }
      return this.place.setStoryMap(map);
    };

    Story_Loader.prototype.filter = function(array, item) {
      var elem, j, len1, output;
      output = [];
      for (j = 0, len1 = array.length; j < len1; j++) {
        elem = array[j];
        if (elem !== item) {
          output.push(elem);
        }
      }
      return output;
    };

    Story_Loader.prototype.removeEOL = function(line) {
      var eol, last_char, len;
      if (line.length < 1) {
        return line;
      }
      eol = line[line.length - 1];
      len = eol.length;
      if (len < 2) {
        return line;
      }
      last_char = eol[len - 1];
      eol = eol.substring(0, len - 1);
      line[line.length - 1] = eol;
      return line;
    };

    return Story_Loader;

  })();

}).call(this);
