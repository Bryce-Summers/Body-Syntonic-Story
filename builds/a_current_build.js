/*! Sim Urban, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 04-04-2018
 */
// All of the boiler plate, example project stuff should be out of a namespace.
// all of the procedural elements unique to a project should be within this projects' specific namespace.

// Defined main namespace.
EX = {};// Example namespace. Necessary for coffeescript files.
        // EX contains demo specific files that are not usable as an api for other projects, but which may be useful for setting up demos for other projects.

/*
 * Defines the Traffic Simulation and Game namespace.
 * All Sim Urban classes are fit into this namespace.
 */
BSS = {};
// Generated by CoffeeScript 1.11.1

/*
 *
 * Element interface class.
 *
 * Written by Bryce Summers on 10.23.2017
 *
 * Elements tie together sets of functional models.
 * - Operating model, contains the mathematics of simulation.
 * - Visual Representation, specifies the display of this element on screen.
 * - Collision Representation, specifies the area or volume that this element takes up on screen.
 * - Audio Representation, specifies the audio that this element emits.
 *
 * Elements are responsible for storing the overarching configuration information and producing representations from it.
 */

(function() {
  BSS.Element = (function() {
    function Element(_model) {
      this._model = _model;
      this._model.setElement(this);
      this._visualRep = new BSS.Visual_Representation();
      this._audioRep = new BSS.Audio_Representation();
      this._mutable = true;
      this._configuration = {};
    }


    /*
    Configuration.
     */

    Element.prototype.setConfiguration = function(config) {
      return this._configuration = config;
    };

    Element.prototype.allowMutations = function() {
      return this._mutable = true;
    };


    /*
    Building.
     */

    Element.prototype.buildFromConfiguration = function() {
      return console.log("Please Implement me in subclass!");
    };


    /*
    General Queries.
     */

    Element.prototype.getConfiguration = function() {
      return this._configuration;
    };

    Element.prototype.getModel = function() {
      return this._model;
    };

    Element.prototype.getVisualRepresentation = function() {
      return this._visualRep;
    };

    Element.prototype.getAudioRepresentation = function() {
      return this._audioRep;
    };


    /*
    getCollisionRepresentation: () ->
        console.log("This is not necessary for keyboard input storytelling. It will be more useful for future games, like Sim Urban.")
        throw new Error("Implement me in subclass please!")
     */

    Element.prototype.getUIWindow = function() {
      return console.log("Please Implement me!");
    };

    return Element;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Agent_Element = (function(superClass) {
    extend(Agent_Element, superClass);

    function Agent_Element() {
      Agent_Element.__super__.constructor.call(this, new BSS.Agent_Model());
      this.buildFromConfiguration();
    }


    /* Representation building from path mathmatics. */

    Agent_Element.prototype.buildFromConfiguration = function() {
      var character_visual, container, loc, model, pivot, ref, up;
      container = this.getVisualRepresentation();
      container.clearVisuals();
      model = this.getModel();
      ref = model.getCurrentLocationAndHeading(), loc = ref[0], up = ref[1];
      character_visual = EX.Visual_Factory.newPoint(loc, EX.style.c_car_fill, EX.style.radius_agent_default);
      container.addVisual(character_visual);
      pivot = EX.Visual_Factory.newSprite("/assets/images/up_arrow.png", {
        x: -10,
        y: -10,
        w: 20,
        h: 10
      });
      this.arrow = new THREE.Object3D();
      this.arrow.add(pivot);
      this.arrow.position.z += .001;
      container.addVisual(this.arrow);
    };

    Agent_Element.prototype.reposition = function() {
      var loc, psy, ref, up, visual;
      ref = this.getModel().getCurrentLocationAndHeading(), loc = ref[0], up = ref[1];
      visual = this.getVisualRepresentation();
      visual.setPosition(loc);
      visual.setUpDirection(up);
      psy = this.getModel().lookupKey("psychology");
      if (psy === "left") {
        this.arrow.rotation.z = -Math.PI / 2 * .1 + .9 * this.arrow.rotation.z;
      }
      if (psy === "right") {
        this.arrow.rotation.z = Math.PI / 2 * .1 + .9 * this.arrow.rotation.z;
      }
      if (psy === "up") {
        this.arrow.rotation.z = 0 * .1 + .9 * this.arrow.rotation.z;
      }
    };

    Agent_Element.prototype.getRepresentationLocationAndHeading = function() {
      var angle, dx, dy, loc, pos, tan, visual;
      visual = this.getVisualRepresentation();
      pos = visual.getPosition();
      loc = new BDS.Point(pos.x, pos.y);
      angle = visual.getRotation();
      dx = Math.cos(angle);
      dy = Math.sin(angle);
      tan = new BDS.Point(dx, dy);
      return [loc, tan];
    };


    /* Element Interface. */

    return Agent_Element;

  })(BSS.Element);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Condition_Element = (function(superClass) {
    extend(Condition_Element, superClass);

    function Condition_Element() {
      Condition_Element.__super__.constructor.call(this, new BSS.Condition_Model());
      this.buildFromConfiguration();
    }

    Condition_Element.prototype.buildFromConfiguration = function() {};

    return Condition_Element;

  })(BSS.Element);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Junction_Element = (function(superClass) {
    extend(Junction_Element, superClass);

    function Junction_Element() {
      Junction_Element.__super__.constructor.call(this, new BSS.Junction_Model());
    }

    return Junction_Element;

  })(BSS.Element);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Operator_Element = (function(superClass) {
    extend(Operator_Element, superClass);

    function Operator_Element() {
      Operator_Element.__super__.constructor.call(this, new BSS.Operator_Model());
      this._path = null;
      this._percentage = null;
      this.buildFromConfiguration();
    }

    Operator_Element.prototype.setFunction = function(func) {
      return this.getModel().setFunction(func);
    };


    /* Representation building from path mathmatics. */

    Operator_Element.prototype.buildFromConfiguration = function() {
      var container, number, operator_visual;
      container = this.getVisualRepresentation();
      container.clearVisuals();
      operator_visual = EX.Visual_Factory.newPoint(new BDS.Point(0, 0), EX.style.c_operator_fill, EX.style.radius_operator_default);
      container.addVisual(operator_visual);
      number = EX.Visual_Factory.new_label("1");
      number.position.x = -1;
      container.addVisual(number);
    };

    Operator_Element.prototype.reposition = function() {
      var loc, ref, up, visual;
      ref = this.getCurrentLocationAndHeading(), loc = ref[0], up = ref[1];
      visual = this.getVisualRepresentation();
      visual.setPosition(loc);
      visual.setUpDirection(up);
    };

    Operator_Element.prototype.setPath = function(path, percentage) {
      this._path = path;
      return this._percentage = percentage;
    };

    Operator_Element.prototype.getCurrentLocationAndHeading = function() {
      return this._path.getLocation(this._percentage);
    };

    Operator_Element.prototype.getRepresentationLocationAndHeading = function() {
      var angle, dx, dy, loc, pos, tan, visual;
      visual = this.getVisualRepresentation();
      pos = visual.getPosition();
      loc = new BDS.Point(pos.x, pos.y);
      angle = visual.getRotation();
      dx = Math.cos(angle);
      dy = Math.sin(angle);
      tan = new BDS.Point(dx, dy);
      return [loc, tan];
    };


    /* Element Interface. */

    return Operator_Element;

  })(BSS.Element);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Path_Element = (function(superClass) {
    extend(Path_Element, superClass);

    function Path_Element(mid_line) {
      Path_Element.__super__.constructor.call(this, new BSS.Path_Model());
      this.mid_line = mid_line;
      this.partial_distances = this.mid_line.computeCumulativeLengths();
      this.getModel().setTransversalLength(this.partial_distances[this.partial_distances.length - 1]);
      this.tangent_angles = this.mid_line.computeTangentAngles();
      this.tangent_angles.push(this.tangent_angles[this.tangent_angles.length - 1]);
      this.path_radius = EX.style.radius_path_default;
      this.buildFromConfiguration();
    }


    /* Representation building from path mathmatics. */

    Path_Element.prototype.buildFromConfiguration = function() {
      var container, path_visual;
      container = this._visualRep;
      container.clearVisuals();
      path_visual = EX.Visual_Factory.newPath(this.mid_line, this.path_radius, EX.style.c_road_fill, true);
      container.addVisual(path_visual);
    };


    /* Element Interface. */

    Path_Element.prototype.getLocation = function(percentage) {
      var ang0, ang1, highest_le_index, i0, i1, len, location, partial_distance, pd0, pd1, per, pt0, pt1, tangent, tangent_angle, tx, ty;
      if (percentage === void 0) {
        throw new Error("percentage undefined");
      }
      partial_distance = percentage * this.getModel().getTransversalLength();
      highest_le_index = BDS.Arrays.binarySearch(this.partial_distances, partial_distance, function(a, b) {
        return a <= b;
      });
      len = this.mid_line.size();
      i0 = highest_le_index;
      if (i0 === len - 1) {
        i0 = len - 2;
      }
      i1 = i0 + 1;
      pd0 = this.partial_distances[i0];
      pd1 = this.partial_distances[i1];
      per = (partial_distance - pd0) / (pd1 - pd0);
      pt0 = this.mid_line.getPoint(i0);
      pt1 = this.mid_line.getPoint(i1);
      ang0 = this.tangent_angles[i0];
      ang1 = this.tangent_angles[i1];
      tangent_angle = BDS.Math.lerp(ang0, ang1, per);
      location = pt0.multScalar(1.0 - per).add(pt1.multScalar(per));
      tx = Math.cos(tangent_angle);
      ty = Math.sin(tangent_angle);
      tangent = new BDS.Point(tx, ty);
      return [location, tangent];
    };

    Path_Element.prototype.addAgent = function(agent) {
      var path_model;
      path_model = this.getModel();
      return path_model.enqueueAgent(agent.getModel());
    };

    Path_Element.prototype.addOperator = function(operator, percentage) {
      var operator_model, path_model;
      path_model = this.getModel();
      operator_model = operator.getModel();
      path_model.addOperator(operator_model, percentage);
      operator.setPath(this, percentage);
      return operator.reposition();
    };

    Path_Element.prototype.getCrossSectionRadius = function() {
      return this.path_radius;
    };


    /* Inputs */

    Path_Element.prototype.time = function(dt) {
      return this.getModel().moveAgents(dt);
    };

    return Path_Element;

  })(BSS.Element);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Place_Element = (function(superClass) {
    extend(Place_Element, superClass);

    function Place_Element(scene) {
      this.scene = scene;
      Place_Element.__super__.constructor.call(this, new BSS.Place_Model);
      this.init();
    }

    Place_Element.prototype.init = function() {
      this._places = new Set();
      this._camera_model = new BSS.Camera_Model();
      this._junctions = new Set();
      this._conditions = new Set();
      this._paths = new Set();
      this._operators = new Set();
      this._agents = new Set();
      this._visual_places = new THREE.Object3D();
      this._visual_junctions = new THREE.Object3D();
      this._visual_paths = new THREE.Object3D();
      this._visual_operators = new THREE.Object3D();
      this._visual_conditions = new THREE.Object3D();
      this._visual_agents = new THREE.Object3D();
      return this._story_map = null;
    };

    Place_Element.prototype.setVisualRepresentation = function(visual) {
      var obj;
      obj = this.getVisualRepresentation();
      return obj.add(visual);
    };

    Place_Element.prototype.populateViewLevels = function(levels, N) {
      levels[1].add(this._visual_places);
      levels[1].add(this._visual_junctions);
      levels[2].add(this._visual_paths);
      levels[2].add(this._visual_agents);
      levels[3].add(this._visual_operators);
      return levels[3].add(this._visual_conditions);

      /*
      @_places.forEach (element) =>
          levels[1].add(element.getVisualRepresentation())
      
      @_junctions.forEach (element) =>
          levels[1].add(element.getVisualRepresentation())
      
      @_paths.forEach (element) =>
          levels[2].add(element.getVisualRepresentation())
      
      @_operators.forEach (element) =>
          levels[3].add(element.getVisualRepresentation())
      @_conditions.forEach (element) =>
          levels[3].add(element.getVisualRepresentation())
       */
    };

    Place_Element.prototype.getScene = function() {
      return this.scene;
    };

    Place_Element.prototype.addPlace = function(element) {
      this._places.add(element);
      return this._visual_places.add(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.addJunction = function(element) {
      this._junction.add(element);
      return this._visual_junctions.add(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.addCondition = function(element) {
      this._conditions.add(element);
      return this._visual_conditions.add(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.addPath = function(element) {
      this._paths.add(element);
      return this._visual_paths.add(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.addAgent = function(element) {
      this._agents.add(element);
      return this._visual_agents.add(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.addOperator = function(element) {
      this._operators.add(element);
      return this._visual_operators.add(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.removePlace = function(element) {
      this._places["delete"](element);
      return this._visual_places.remove(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.removeJunction = function(element) {
      this._junction["delete"](element);
      return this._visual_junctions.remove(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.removeCondition = function(element) {
      this._conditions["delete"](element);
      return this._visual_conditions.remove(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.removePath = function(element) {
      this._paths["delete"](element);
      return this._visual_paths.remove(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.removeAgent = function(element) {
      this._agents["delete"](element);
      return this._visual_agents.remove(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.removeOperator = function(element) {
      this._operators["delete"](element);
      return this._visual_operators.remove(element.getVisualRepresentation().getVisual());
    };

    Place_Element.prototype.setStoryMap = function(map) {
      var name;
      this._story_map = map;
      name = "start";
      this.loadStoryBlock(name, null, new BDS.Point(200, 0), new BDS.Point(1, 0));
    };

    Place_Element.prototype.loadStoryBlock = function(storyName, last_path, position, up_direction) {
      var agent_model, elem, elements, func, i, len, model, operator, place, ref, storyGenerator, story_name, up;
      storyGenerator = this._story_map[storyName];
      elements = storyGenerator.generateElements(last_path, position, up_direction);
      for (i = 0, len = elements.length; i < len; i++) {
        elem = elements[i];
        if (elem instanceof BSS.Path_Element) {
          this.addPath(elem);
        } else if (elem instanceof BSS.Place_Element) {
          this.addPlace(elem);
        } else if (elem instanceof BSS.Junction_Element) {
          this.addJunction(elem);
        } else if (elem instanceof BSS.Condition_Element) {
          this.addCondition(elem);
        } else if (elem instanceof BSS.Agent_Element) {
          this.addAgent(elem);
          agent_model = elem.getModel();
          if (agent_model.isProtagonist()) {
            this.scene.setFocusAgent(elem);
            this.scene.setFocusPlace(this);
          }
        } else if (elem instanceof BSS.Operator_Element) {
          this.addOperator(elem);
          operator = elem;
          model = operator.getModel();
          if (model.getType() === "story_load") {
            story_name = model.getState("story_name");
            last_path = model.getState("path");
            ref = last_path.getLocation(1.0), position = ref[0], up = ref[1];
            place = this;
            func = function(story_name, pathy, position, up) {
              return function(agent_model) {
                return place.loadStoryBlock(story_name, pathy, position, up);
              };
            };
            model.setFunction(func(story_name, last_path, position, up));
          }
        }
      }
    };


    /* Inputs */

    Place_Element.prototype.time = function(dt) {
      return this._paths.forEach((function(_this) {
        return function(path) {
          return path.time(dt);
        };
      })(this));
    };

    return Place_Element;

  })(BSS.Element);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    SimUrban Scene Object.
    Rewritten by Bryce Summers on 10.23.2017
    
    purpose: This is the root node of all game initialization, storage, and references.

    NOTE: Agents and places are indistinguishable, except that agents are meant to be temporary,
        whereas places are meant to be eternal.
        Places may spawn agents.

    Scenes provide a global interface that handles settings, output related to the focus, and global game messages.
 */

(function() {
  BSS.Scene = (function() {
    function Scene() {
      this.root_visual = new THREE.Scene();
      this.view = new THREE.Object3D();
      this.view.name = "Scene view.";
      this.overlays = new THREE.Object3D();
      this.overlays.position.z = 1.0;
      this.overlays.name = "Overlays.";
      this.pivot = new THREE.Object3D();
      this.pivot.add(this.view);
      this.root_visual.add(this.overlays);
      this.root_visual.add(this.pivot);
      this._view_levels = null;
      this._io_root = null;
      this.init();
      this.init_scene_ui();
    }

    Scene.prototype.getVisualRepresentation = function() {
      return this.root_visual;
    };

    Scene.prototype.getView = function() {
      return this.view;
    };

    Scene.prototype.getPivot = function() {
      return this.pivot;
    };

    Scene.prototype.init = function() {
      var i, j, level, results;
      this._agents = new Set();
      this._active_agents = new Set();
      this._focus_agent = null;
      this._places = new Set();
      this._active_places = new Set();
      this._focus_place = null;
      this._view_levels = [];
      results = [];
      for (i = j = 1; j < 10; i = ++j) {
        level = new THREE.Object3D();
        level.position.z = 1.0 / 10 * i;
        this._view_levels.push(level);
        results.push(this.view.add(level));
      }
      return results;
    };

    Scene.prototype.init_scene_ui = function() {
      this._ui = new EX.UI(1.0);
      this.overlays.add(this._ui.getVisualRepresentation().getVisual());
      return this.ui_elements = {};
    };

    Scene.prototype.getUI = function() {
      return [this._ui, this.ui_elements];
    };

    Scene.prototype.setViewToPlace = function(place) {
      var j, len, level, ref;
      ref = this._view_levels;
      for (j = 0, len = ref.length; j < len; j++) {
        level = ref[j];
        while (level.children.length > 0) {
          level.children.pop();
        }
      }
      return place.populateViewLevels(this._view_levels, 10);
    };

    Scene.prototype.setInputRoot = function(io_root) {
      this._io_root = io_root;
      return this._io_mouse_main = this._io_root.getMouseController();

      /*
      view = @getVisual()
      @_ui = new BSS.E_UI_Game(@)
      view.add(@_ui.getVisual())
       */
    };

    Scene.prototype.time = function(dt) {
      this._active_places.forEach((function(_this) {
        return function(place) {
          return place.time(dt);
        };
      })(this));
    };

    Scene.prototype.activateAgent = function(agent) {
      this._active_agents.add(agent);
    };

    Scene.prototype.deactivateAgent = function(agent) {
      this._active_objects["delete"](agent);
    };

    Scene.prototype.newAgent = function(agent) {
      this._agents.add(agent);
    };

    Scene.prototype.destroyAgent = function(agent) {
      this._agents["delete"](agent);
    };

    Scene.prototype.setFocusAgent = function(agent) {
      return this._focus_agent = agent;
    };

    Scene.prototype.getFocusAgent = function() {
      return this._focus_agent;
    };

    Scene.prototype.setFocusPlace = function(place) {
      return this._focus_place = place;
    };

    Scene.prototype.getFocusPlace = function() {
      return this._focus_place;
    };

    Scene.prototype.activatePlace = function(element) {
      return this._active_places.add(element);
    };

    Scene.prototype.deactivatePlace = function(element) {
      return this._active_places["delete"](element);
    };

    Scene.prototype.addPlace = function(element) {
      return this._places.add(element);
    };

    Scene.prototype.deletePlace = function(element) {
      return this._places["delete"](element);
    };

    return Scene;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.I_All_Main = (function(superClass) {
    extend(I_All_Main, superClass);

    function I_All_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_All_Main.__super__.constructor.call(this);
      this._keyboard_input = new EX.I_Keyboard_Main(this.scene, this.camera);
      this.add_keyboard_input_controller(this._keyboard_input);
      this._time_input = new EX.I_Time_Main(this.scene, this.camera);
      this.add_time_input_controller(this._time_input);
    }

    I_All_Main.prototype.getMouseController = function() {
      return this._mouse_input;
    };

    return I_All_Main;

  })(BDS.Controller_Group);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  EX.I_Keyboard_Interface = (function() {
    function I_Keyboard_Interface(scene, camera) {
      this.scene = scene;
      this.camera = camera;
    }

    I_Keyboard_Interface.prototype.key_down = function(event) {};

    I_Keyboard_Interface.prototype.key_up = function(event) {};

    I_Keyboard_Interface.prototype.time = function(dt) {};

    I_Keyboard_Interface.prototype.isIdle = function() {};

    I_Keyboard_Interface.prototype.finish = function() {};

    return I_Keyboard_Interface;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.I_Keyboard_Main = (function(superClass) {
    extend(I_Keyboard_Main, superClass);

    function I_Keyboard_Main(scene, camera) {
      var controlPlayer;
      this.scene = scene;
      this.camera = camera;
      I_Keyboard_Main.__super__.constructor.call(this);
      controlPlayer = new EX.Keyboard_ControlPlayer(this.scene, this.camera);
      this.add_keyboard_input_controller(controlPlayer);
      controlPlayer.setActive(true);
      this.state = "idle";
    }


    /* Get Controllers. */

    I_Keyboard_Main.prototype.deactivateTools = function() {

      /*
      @road_build_controller.setActive(false)
      @road_build_controller.cancel()
      @road_build_controller.finish()
       */
    };


    /*------------------------------------
      Internal Helper Functions.
    #--------------------------------------
     */


    /* Override global functionality, still passes commands to subtools. */


    /*
    key_down: (event) ->
    
        super(event)
     */

    return I_Keyboard_Main;

  })(BDS.Controller_Group);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  EX.I_Mouse_Interface = (function() {
    function I_Mouse_Interface(scene, camera) {
      this.scene = scene;
      this.camera = camera;
    }

    I_Mouse_Interface.prototype.mouse_down = function(event) {};

    I_Mouse_Interface.prototype.mouse_up = function(event) {};

    I_Mouse_Interface.prototype.mouse_move = function(event) {};

    I_Mouse_Interface.prototype.isIdle = function() {};

    I_Mouse_Interface.prototype.finish = function() {};

    return I_Mouse_Interface;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.I_Mouse_Main = (function(superClass) {
    extend(I_Mouse_Main, superClass);

    function I_Mouse_Main(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      I_Mouse_Main.__super__.constructor.call(this);

      /*
      @ui_controller = new EX.UI_Controller(@scene, @camera)
      @add_mouse_input_controller(@ui_controller)
       */
      this.state = "idle";
    }


    /* Get Controllers. */

    I_Mouse_Main.prototype.deactivateTools = function() {

      /*
      @road_build_controller.setActive(false)
      @road_build_controller.cancel()
      @road_build_controller.finish()
       */
    };


    /*------------------------------------
      Internal Helper Functions.
    #--------------------------------------
     */

    I_Mouse_Main.prototype._create_cursor = function() {
      var h, mesh, mesh_factory, overlays, params, scale, w;
      mesh_factory = new EX.Unit_Meshes();
      params = {
        color: EX.style.cursor_circle_color
      };
      mesh = mesh_factory.newCircle(params);
      scale = EX.style.cursor_circle_radius;
      mesh.position.z = EX.style.cursor_circle_z;
      w = scale;
      h = scale;
      scale = mesh.scale;
      scale.x = w;
      scale.y = h;
      overlays = this.scene.getOverlays();
      overlays.addPermanentVisual(mesh);
      return this.pointer = mesh;
    };

    I_Mouse_Main.prototype.mouse_move = function(event) {
      var pos;
      I_Mouse_Main.__super__.mouse_move.call(this, event);
      pos = this.pointer.position;
      pos.x = event.x;
      return pos.y = event.y;
    };

    return I_Mouse_Main;

  })(BDS.Controller_Group);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  EX.I_Time_Interface = (function() {
    function I_Time_Interface(scene, camera) {
      this.scene = scene;
      this.camera = camera;
    }

    I_Time_Interface.prototype.time = function(dt) {};

    I_Time_Interface.prototype.isIdle = function() {};

    I_Time_Interface.prototype.finish = function() {};

    return I_Time_Interface;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Time Input Controller.

Written by Bryce Summmers on 1 - 31 - 2017.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.I_Time_Main = (function(superClass) {
    extend(I_Time_Main, superClass);

    function I_Time_Main(scene, camera) {
      var cameraFollowsAgent, sceneTimer, updateUIFromFocusAgent;
      this.scene = scene;
      this.camera = camera;
      I_Time_Main.__super__.constructor.call(this);
      cameraFollowsAgent = new EX.TimeTool_CameraFollowsAgent(this.scene, this.camera);
      this.add_time_input_controller(cameraFollowsAgent);
      cameraFollowsAgent.setActive(true);
      sceneTimer = new EX.TimeTool_SceneTimer(this.scene, this.camera);
      this.add_time_input_controller(sceneTimer);
      sceneTimer.setActive(true);
      updateUIFromFocusAgent = new EX.TimeTool_DisplayFocusAgentStatistics(this.scene, this.camera);
      this.add_time_input_controller(updateUIFromFocusAgent);
      updateUIFromFocusAgent.setActive(true);
    }

    return I_Time_Main;

  })(BDS.Controller_Group);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  EX.I_Tool_Controller = (function() {
    function I_Tool_Controller(scene, camera) {
      this.scene = scene;
      this.camera = camera;
    }

    I_Tool_Controller.prototype.setActive = function(val) {
      return this.active = val;
    };

    I_Tool_Controller.prototype.isActive = function() {
      return this.active;
    };

    return I_Tool_Controller;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

UI Input Controller.

Written by Bryce Summers on May.4.2017

Purpose: 
 - Manages a bunch of UI elements and triggering their actions.
 - Handles the coloring and visual display logic for UI elements.

Notes:
 - This class has been adapted from BDS.Controller_UI.
   the only difference is our use of three.js, instead of canvas drawing.
   I think that we could abstract the canvas drawing into a scene graph 
   and then these paradigms will be more aligned.
 */

(function() {
  EX.UI_Controller = (function() {
    function UI_Controller(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      this._mouse_pressed = false;
      this._hover_element = null;
      this._clicked_element = null;
      this._c_resting = new THREE.Color(0xe6dada);
      this._c_hover_nopress = new THREE.Color(0xfaf8f8);
      this._c_hover_pressed = new THREE.Color(0xa0a0a0);
      this._c_nohover_press = new THREE.Color(0xc7acac);
      this._active = true;
    }

    UI_Controller.prototype.setActive = function(isActive) {
      return this._active = isActive;
    };

    UI_Controller.prototype.isActive = function() {
      return this._active;
    };

    UI_Controller.prototype.mouse_down = function(event) {
      if (this._mouse_pressed) {
        return;
      }
      this._mouse_pressed = true;
      if (this._hover_element !== null) {
        this._clicked_element = this._hover_element;
        return this._clicked_element.material.color = this._c_hover_pressed;
      }
    };

    UI_Controller.prototype.mouse_move = function(event) {
      var element, polyline, pt;
      pt = new BDS.Point(event.x, event.y);
      polyline = this.scene.getUI().query_point(pt);
      element = null;
      if (polyline !== null) {
        element = polyline.getAssociatedData();
      }
      if (this._hover_element !== null) {
        this._hover_element.color = this._c_resting;
      }
      this._hover_element = element;
      if (this._hover_element !== null) {
        this._hover_element.material.color = this._c_hover_nopress;
      }
      if (this._clicked_element !== null) {
        if (this._clicked_element === this._hover_element) {
          return this._clicked_element.material.color = this._c_hover_pressed;
        } else {
          return this._clicked_element.material.color = this._c_hover_nopress;
        }
      }
    };

    UI_Controller.prototype.mouse_up = function(event) {
      if (!this._mouse_pressed) {
        return;
      }
      if (this._clicked_element === null) {
        this.finish();
        return;
      }
      if (this._hover_element === this._clicked_element) {
        this._hover_element.click();
        this._hover_element.material.color = this._c_hover_nopress;
      }
      return this.finish();
    };

    UI_Controller.prototype.time = function(dt) {};

    UI_Controller.prototype.window_resize = function(event) {};

    UI_Controller.prototype.finish = function() {
      this._mouse_pressed = false;
      return this._clicked_element = null;
    };

    return UI_Controller;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Super class to mesh construction classes.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
        Deals with all of the common problems such as adding a material and changing its color.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.Mesh_Basic = (function(superClass) {
    extend(Mesh_Basic, superClass);

    function Mesh_Basic(area_geometry, outline_geometry) {
      this.outline_geometry = outline_geometry;
      this.fill_material = EX.style.m_default_fill.clone();
      Mesh_Basic.__super__.constructor.call(this, area_geometry, this.fill_material);
      this.line_material = EX.style.m_default_line.clone();
    }

    Mesh_Basic.prototype.clone = function(params) {

      /*
      geometry = new THREE.CircleGeometry( .5, 32 );
      material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
      circle = new THREE.Mesh( geometry, material );
      circle.scale.x = params.scale.x
      circle.scale.y = params.scale.y
      circle.position.x = params.position.x
      circle.position.y = params.position.y
      #circle.rotation.x = Math.PI/4
      #circle.rotation.y = Math.PI/4
      #circle.rotation.z = Math.PI/4
      return circle
       */
      var geometry, mesh, outline, output;
      output = new THREE.Object3D();
      geometry = this.geometry;
      mesh = new EX.Mesh_Basic(this.geometry);
      outline = new THREE.Line(this.outline_geometry, this.line_material);
      outline.renderOrder = 1;
      output.add(mesh);
      output.add(outline);
      if (params.material) {
        mesh.material = params.material;
      }
      if (params.color) {
        if (!(params.color instanceof THREE.Color)) {
          debugger;
        }
        mesh.material.color = params.color;
      }
      if (params.scale) {
        output.scale.copy(params.scale.clone());
      }
      if (params.position) {
        output.position.copy(params.position.clone());
      }
      output.setFillColor = function(c) {
        return this.children[0].material.color = c;
      };
      output.revertFillColor = function() {
        return this.children[0].material.color = EX.style.m_default_fill.color.clone();
      };
      return output;
    };

    return Mesh_Basic;

  })(THREE.Mesh);

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  EX.Unit_Meshes = (function() {
    function Unit_Meshes() {
      this._square = new EX.Mesh_Unit_Square();
      this._circle = new EX.Mesh_Unit_Circle();
      this._triangle = new EX.Mesh_Unit_Triangle();
    }

    Unit_Meshes.prototype.newSquare = function(params) {
      return this._square.clone(params);
    };

    Unit_Meshes.prototype.newCircle = function(params) {
      return this._circle.clone(params);
    };

    Unit_Meshes.prototype.newTriangle = function(params) {
      return this._triangle.clone(params);
    };

    return Unit_Meshes;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Model Interface Class.
 * This specifies properties of all element objects.
 *
 * Written by Bryce Summers on 10.23.2017
 */

(function() {
  BSS.Model = (function() {
    function Model() {
      this._ui = null;
    }

    Model.prototype.listNeighbors = function() {
      return console.log("Please Implement me!");
    };

    Model.prototype.heuristicTo = function(element) {
      return console.log("Please Implement me!");
    };

    Model.prototype.getLocation = function() {
      return console.log("Please Implement me!");
    };

    Model.prototype.setElement = function(element) {
      return this._element = element;
    };

    Model.prototype.getElement = function() {
      return this._element;
    };

    return Model;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    Objects are agents that try to do stuff. They carry along data, then sleep.

    Objects are responsible for determining when statistics ought to be logged,
    when plans should be created, and for following the rules.

    Objects do not actively update themselves, 
    but rather they passively receive updates from classes such as paths that manage their behavior.

    IDEA: Look up behavior trees.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Agent_Model = (function(superClass) {
    extend(Agent_Model, superClass);

    function Agent_Model(scene) {
      this.scene = scene;
      this.active = null;
      this.state = {};
      this.speed = 60;
      this.speed_multiple = 1;
      this.age = "adult";
      this.protagonist = false;
      this.statistics = null;
      this.navigation = null;
      this.percentage = 0;
      this.next_agent = null;
      this.companion_left = null;
      this.companion_right = null;
      this.leader = null;
      this.representation = null;
      this.buildModel();
    }

    Agent_Model.prototype.buildModel = function() {
      this.statistics = new BSS.Statistics_Model();
      this.navigation = new BSS.Navigation_Model();
      this.percentage = 0;
      this.state = {};
      this.active = false;
      return this.state["psychology"] = "stopped";
    };

    Agent_Model.prototype.getNavigation = function() {
      return this.navigation;
    };

    Agent_Model.prototype.getStatistics = function() {
      return this.statistics;
    };

    Agent_Model.prototype.getPercentage = function() {
      return this.percentage;
    };

    Agent_Model.prototype.getCurrentLocationAndHeading = function() {
      var path_element, path_model;
      path_model = this.navigation.getCurrentLocation();
      if (path_model !== null && path_model instanceof BSS.Path_Model) {
        path_element = path_model.getElement();
        return path_element.getLocation(this.percentage);
      }
      return this.getElement().getRepresentationLocationAndHeading();
    };

    Agent_Model.prototype.moveAlongPath = function(dt, percentages_per_meter) {
      var dPercentage, psychology;
      psychology = this.state["psychology"];
      dPercentage = 0;
      if (psychology === "up" || psychology === "left" || psychology === "right") {
        dPercentage = dt * this.speed * this.speed_multiple * percentages_per_meter;
      } else {
        return;
      }
      this.percentage += dPercentage;
      this.getElement().reposition();
    };

    Agent_Model.prototype.setPercentage = function(per) {
      this.percentage = per;
      return this.getElement().reposition();
    };

    Agent_Model.prototype.activate = function() {
      this.scene.activateObject(this);
      return this.active = true;
    };

    Agent_Model.prototype.deactivate = function() {
      this.scene.deactivateObject(this);
      return this.active = false;
    };

    Agent_Model.prototype.lookupKey = function(key) {
      return this.state[key];
    };

    Agent_Model.prototype.setKey = function(key, val) {
      this.state[key] = val;
    };

    Agent_Model.prototype.getNextAgent = function(agent) {
      return this.next_agent;
    };

    Agent_Model.prototype.setNextAgent = function(agent) {
      this.next_agent = agent;
    };

    Agent_Model.prototype.setLeftCompanion = function(agent) {
      this.companion_left = agent;
      agent.leader = this;
      agent.setKey("psychology", "follow");
    };

    Agent_Model.prototype.setRightCompanion = function(agent) {
      this.companion_right = agent;
      agent.leader = this;
      agent.setKey("psychology", "follow");
    };

    Agent_Model.prototype.getLeftCompanion = function() {
      return this.companion_left;
    };

    Agent_Model.prototype.getRightCompanion = function() {
      return this.companion_right;
    };

    Agent_Model.prototype.getAllCompanions = function() {
      var left, out, right;
      left = this.companion_left;
      right = this.companion_right;
      out = [];
      while (left !== null) {
        out.push(left);
        left = left.getLeftCompanion();
      }
      while (right !== null) {
        out.push(right);
        right = right.getRightCompanion();
      }
      return out;
    };

    Agent_Model.prototype.getCurrentLocationModel = function() {
      return this.navigation.getCurrentLocation();
    };

    Agent_Model.prototype.operate = function(operator) {
      var func;
      func = operator.getFunction();
      func(this);
    };

    Agent_Model.prototype.setSpeed = function(speed) {
      return this.speed_multiple = speed;
    };

    Agent_Model.prototype.setCharacterType = function(age, protagonist) {
      this.age = age;
      if (protagonist) {
        return this.protagonist = true;
      } else {
        return this.protagonist = false;
      }
    };

    Agent_Model.prototype.isProtagonist = function() {
      return this.protagonist;
    };

    return Agent_Model;

  })(BSS.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    A Model for a current camera view of a place.
    These are preserved between visits to places.

    This is used to determine the movement properties.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Camera_Model = (function(superClass) {
    extend(Camera_Model, superClass);

    function Camera_Model() {
      this.center = new BDS.Point(0, 0);
      this.up = new BDS.Point(0, -1);
      this.angle = 0;
      this.interpolationFactor = .1;
    }

    Camera_Model.prototype.buildModel = function() {};

    Camera_Model.prototype.setCenter = function(pt) {
      return this.center = pt.clone();
    };

    Camera_Model.prototype.getCenter = function() {
      return this.center;
    };

    Camera_Model.prototype.setUpDirection = function(dir) {
      this.up = dir.normalize();
      return this.angle = Math.atan2(this.up.y, this.up.x) + Math.PI / 2;
    };

    Camera_Model.prototype.getUpDirection = function() {
      return this.up;
    };

    Camera_Model.prototype.setInterpolationFactor = function(per) {
      return this.interpolationFactor = per;
    };

    Camera_Model.prototype.getInterpolationFactor = function() {
      return this.interpolationFactor;
    };

    Camera_Model.prototype.applyToCamera = function(camera) {
      var current_angle, pos_old;
      pos_old = camera.position;
      camera.position.x = (1.0 - this.interpolationFactor) * pos_old.x + this.interpolationFactor * this.center.x;
      camera.position.y = (1.0 - this.interpolationFactor) * pos_old.y + this.interpolationFactor * this.center.y;
      current_angle = camera.rotation.z;
      while (this.angle > current_angle + Math.PI) {
        this.angle -= Math.PI * 2;
      }
      while (this.angle < current_angle - Math.PI) {
        this.angle += Math.PI * 2;
      }
      return camera.rotation.z = (1.0 - this.interpolationFactor) * camera.rotation.z + this.interpolationFactor * this.angle;
    };

    Camera_Model.prototype.applyInverseToObj = function(pivot, view, camera) {
      var angle, current_angle, pos_old;
      pos_old = view.position;
      view.position.x = (1.0 - this.interpolationFactor) * pos_old.x + this.interpolationFactor * (-this.center.x);
      view.position.y = (1.0 - this.interpolationFactor) * pos_old.y + this.interpolationFactor * (-this.center.y);
      pivot.position.x = camera.position.x;
      pivot.position.y = camera.position.y;

      /*
      obj.position.x = 600
      obj.position.y = 600
       */
      current_angle = pivot.rotation.z;
      angle = camera.rotation.z - this.angle;
      while (angle > current_angle + Math.PI) {
        angle -= Math.PI * 2;
      }
      while (angle < current_angle - Math.PI) {
        angle += Math.PI * 2;
      }
      return pivot.rotation.z = (1.0 - this.interpolationFactor) * pivot.rotation.z + this.interpolationFactor * angle;
    };

    return Camera_Model;

  })(BSS.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on Mar.29.2018

    Conditional models allow either accept or reject a given object model depending
    this conditional model's prediated test configuration.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Condition_Model = (function(superClass) {
    extend(Condition_Model, superClass);


    /*
    @EQ = "="
    @LE = "<="
    @GE = ">="
    @LT = "<"
    @GT = ">"
    @NE = "!="
    
    @VAR = 0 # Key is a name of variable to be looked up in the object.
    @CONSTANT = 1 # key is a constant used for being compared to.
     */

    function Condition_Model() {
      this._conditions = [];
      this._paths = [];
    }

    Condition_Model.prototype.associateCondition = function(key, val, path_element) {
      this._conditions.push(key);
      return this._paths.push(val);
    };

    Condition_Model.prototype.getDestination = function(agent) {
      var i, j, key, ref;
      for (i = j = 0, ref = this._conditions.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        key = this._conditions[i];
        if (key(agent)) {
          return this._paths[i];
        }
      }
      throw new Error("No valid conditional path found.");
      return null;
    };


    /*
    buildModel: () ->
    
    evaluateObject: (obj) ->
    
        if @type1 == BSS.Condition_Model.VAR
            val1 = obj.lookup(@key1)
        else # Constant.
            val1 = @key1
    
        if @type2 == BSS.Condition_Model.VAR
            val2 = obj.lookupKey(@key2)
        else # Constant.
            val2 = @key2
    
        switch @operator
            when BSS.Condition_Model.EQ then return val1 == val2
            when BSS.Condition_Model.LE then return val1 <= val2
            when BSS.Condition_Model.GE then return val1 >= val2
            when BSS.Condition_Model.LT then return val1 <  val2
            when BSS.Condition_Model.GT then return val1 >  val2
            when BSS.Condition_Model.NE then return val1 != val2
            else console.log("Conditional: " + @operator + " is not defined.")
     */

    return Condition_Model;

  })(BSS.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Junction_Model = (function(superClass) {
    extend(Junction_Model, superClass);

    function Junction_Model() {
      this._configurations = null;
    }

    Junction_Model.prototype.buildModel = function() {};

    return Junction_Model;

  })(BSS.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    A model for the navigation of an object.

    This handles all of the logic for location and the creation of plans.
    Objects determine when to plan.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Navigation_Model = (function(superClass) {
    extend(Navigation_Model, superClass);

    function Navigation_Model() {
      this.current_location_model = null;
      this.destination = null;
      this.plan_stack = [];
      this.finished_plan_stack = [];
    }

    Navigation_Model.prototype.getCurrentLocation = function() {
      return this.current_location_model;
    };

    Navigation_Model.prototype.setCurrentLocation = function(path_model) {
      return this.current_location_model = path_model;
    };

    Navigation_Model.prototype.setDestination = function(path_model) {
      return this.destination = path_model;
    };

    Navigation_Model.prototype.updatePlan = function() {};

    return Navigation_Model;

  })(BSS.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017
    Updated on Mar.29.2018
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Operator_Model = (function(superClass) {
    extend(Operator_Model, superClass);

    function Operator_Model() {
      this._mutation_function = null;
      this._type = "normal";
      this._state = {};
    }

    Operator_Model.prototype.buildModel = function() {};

    Operator_Model.prototype.setFunction = function(func) {
      return this._mutation_function = func;
    };

    Operator_Model.prototype.getFunction = function() {
      return this._mutation_function;
    };

    Operator_Model.prototype.setType = function(type) {
      return this._type = type;
    };

    Operator_Model.prototype.getType = function() {
      return this._type;
    };

    Operator_Model.prototype.setState = function(key, val) {
      return this._state[key] = val;
    };

    Operator_Model.prototype.getState = function(key) {
      return this._state[key];
    };

    return Operator_Model;

  })(BSS.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Path_Model = (function(superClass) {
    extend(Path_Model, superClass);

    function Path_Model() {
      this._capacity = 1;
      this._occupancy = 0;
      this._cost = 1;
      this._distance = 1;
      this.destination = null;
      this.last_agent = null;
      this.lane_left = null;
      this.lane_right = null;
      this.operators = [];
    }

    Path_Model.prototype.moveAgents = function(dt) {
      var agent, c, companions, j, k, l, lane, len, len1, len2, len3, m, navigation, next_path, oper, oper_index, path_model, per_end, per_operator, per_start, percentages_per_meter;
      agent = this.last_agent;
      percentages_per_meter = 1.0 / this._distance;
      while (agent !== null && agent.getNavigation().getCurrentLocation() === this) {
        if (agent.lookupKey("psychology") === "follow") {
          agent = agent.getNextAgent();
          continue;
        }
        per_start = agent.getPercentage();
        agent.moveAlongPath(dt, percentages_per_meter);
        per_end = agent.getPercentage();
        companions = agent.getAllCompanions();
        for (j = 0, len = companions.length; j < len; j++) {
          c = companions[j];
          c.setPercentage(per_end);
        }
        companions.push(agent);
        for (k = 0, len1 = companions.length; k < len1; k++) {
          c = companions[k];
          lane = c.getNavigation().getCurrentLocation();
          oper_index = lane.getNextOperatorIndex(per_start);
          if (oper_index !== null) {
            oper = lane.operators[oper_index];
            per_operator = oper.percentage;
            while (oper_index < lane.operators.length && oper.percentage <= per_end) {
              agent.operate(oper.operator);
              for (l = 0, len2 = companions.length; l < len2; l++) {
                c = companions[l];
                c.operate(oper.operator);
              }
              oper_index += 1;
              oper = lane.operators[oper_index];
            }
          }
        }
        if (per_end > 1.0) {
          for (m = 0, len3 = companions.length; m < len3; m++) {
            agent = companions[m];
            navigation = agent.getNavigation();
            path_model = navigation.getCurrentLocation();
            next_path = path_model.getDestination(agent);
            if (path_model.endsAtConditional()) {
              if (agent.lookupKey("psychology") !== "follow") {
                agent.setKey("psychology", "up");
              }
            }
            if (next_path !== null) {
              path_model.dequeueAgent(agent);
              next_path.enqueueAgent(agent);
              navigation.setCurrentLocation(next_path);

              /*
              Ideally we should move the agent through without a hitch, activating all operators along the way,
              includng the ones on the next path.
              dist = (per_end - 1.0) / percentages_per_meter
              per = dist / next_path.length...
               */
              agent.setPercentage(0.0);
            } else {
              agent.setPercentage(1.0);
            }
          }
        }
        agent = agent.getNextAgent();
      }
    };

    Path_Model.prototype.setCapacity = function(capacity) {
      return this._capacity = capacity;
    };

    Path_Model.prototype.setTransversalCost = function(cost) {
      return this._cost = cost;
    };

    Path_Model.prototype.setTransversalLength = function(length) {
      return this._distance = length;
    };

    Path_Model.prototype.setDestination = function(model) {
      return this.destination = model;
    };

    Path_Model.prototype.getDestination = function(agent_model) {
      if (this.endsAtConditional()) {
        return this.destination.getDestination(agent_model);
      }
      return this.destination;
    };

    Path_Model.prototype.endsAtConditional = function() {
      return this.destination instanceof BSS.Condition_Model;
    };

    Path_Model.prototype.getTransversalLength = function() {
      return this._distance;
    };

    Path_Model.prototype.isClear = function() {
      return this._occupancy === 0;
    };

    Path_Model.prototype.enqueueAgent = function(agent_model) {
      var navigation_model;
      navigation_model = agent_model.getNavigation();
      navigation_model.setCurrentLocation(this);
      agent_model.setNextAgent(this.last_agent);
      agent_model.getElement().reposition();
      return this.last_agent = agent_model;
    };

    Path_Model.prototype.dequeueAgent = function(agent_model) {};

    Path_Model.prototype.getNextOperatorIndex = function(percentage) {
      var lower_bound, oper;
      oper = {
        operator: null,
        percentage: percentage
      };
      lower_bound = BDS.Arrays.binarySearch(this.operators, oper, function(a, b) {
        return a.percentage <= b.percentage;
      });
      if (lower_bound >= this.operators.length - 1) {
        return null;
      }
      return lower_bound + 1;
    };

    Path_Model.prototype.addOperator = function(operator, percentage) {
      var i, insert_index, j, k, new_opers, oper, ref, ref1, ref2;
      oper = {
        operator: operator,
        percentage: percentage
      };
      insert_index = BDS.Arrays.binarySearch(this.operators, oper, function(a, b) {
        return a.percentage <= b.percentage;
      });
      new_opers = [];
      for (i = j = 0, ref = insert_index; j <= ref; i = j += 1) {
        new_opers.push(this.operators[i]);
      }
      new_opers.push(oper);
      for (i = k = ref1 = insert_index + 1, ref2 = this.operators.length; k < ref2; i = k += 1) {
        new_opers.push(this.operators[i]);
      }
      this.operators = new_opers;
    };

    Path_Model.prototype.setLeftLane = function(path) {
      if (this.lane_left !== null) {
        this.lane_left.lane_right = null;
      }
      this.lane_left = path;
      if (path !== null) {
        this.lane_left.lane_right = this;
      }
    };

    Path_Model.prototype.setRightLane = function(path) {
      if (this.lane_right !== null) {
        this.lane_right.lane_left = null;
      }
      this.lane_right = path;
      if (path !== null) {
        return this.lane_right.lane_left = this;
      }
    };

    Path_Model.prototype.getLeftLane = function() {
      return this.lane_left;
    };

    Path_Model.prototype.getRightLane = function() {
      return this.lane_right;
    };

    Path_Model.prototype.getAllLanes = function() {
      var out;
      out = this.getAllOtherLanes();
      out.push(this);
      return out;
    };

    Path_Model.prototype.getFarLeftLane = function() {
      var out;
      out = this;
      while (out.getLeftLane() !== null) {
        out = out.getLeftLane();
      }
      return out;
    };

    Path_Model.prototype.getFarRightLane = function() {
      var out;
      out = this;
      while (out.getRightLane() !== null) {
        out = out.getRightLane();
      }
      return out;
    };

    Path_Model.prototype.getAllOtherLanes = function() {
      var left, out, right;
      left = this.lane_left;
      right = this.lane_right;
      out = [];
      while (left !== null) {
        out.push(left);
        left = left.getLeftLane();
      }
      while (right !== null) {
        out.push(right);
        right = right.getRightLane();
      }
      return out;
    };

    Path_Model.prototype.getAllLanes = function() {
      var lane, out;
      out = [];
      lane = this.getFarLeftLane();
      while (lane !== null) {
        out.push(lane);
        lane = lane.getRightLane();
      }
      return out;
    };

    return Path_Model;

  })(BSS.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Place Class.
    Defines a place model.
    Written by Bryce Summers on 10.23.2017
        
    The User is always viewing a visual representation of a place model.
    There are also a set of active places currently in the model hiearchy handled by the scene object.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Place_Model = (function(superClass) {
    extend(Place_Model, superClass);

    function Place_Model() {
      this._object_spawners = null;
      this._camera_model = new BSS.Camera_Model();
    }

    Place_Model.prototype.getCamera = function() {
      return this._camera_model;
    };

    Place_Model.prototype.setCamera = function(model) {
      return this._camera_model = model;
    };

    return Place_Model;

  })(BSS.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    A model for the statistics of an object.

    This is specific the agents within a particular game.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Statistics_Model = (function(superClass) {
    extend(Statistics_Model, superClass);

    function Statistics_Model() {
      this._food = 0;
      this._foodChanged = true;
      this.experiences = 0;
      this._narrative = "Press Up Key to begin journey!";
      this._narrativeChanged = true;
    }

    Statistics_Model.prototype.buildModel = function() {};


    /*
    Food.
     */

    Statistics_Model.prototype.foodChanged = function() {
      if (this._foodChanged) {
        this._foodChanged = false;
        return true;
      }
      return false;
    };

    Statistics_Model.prototype.getFood = function() {
      return this._food;
    };

    Statistics_Model.prototype.setFood = function(val) {
      this._food = val;
      return this._foodChanged = true;
    };


    /*
    Narration. Controls the text that represent's this agent's current inner narrative.
     */

    Statistics_Model.prototype.narrativeChanged = function() {
      if (this._narrativeChanged) {
        this._narrativeChanged = false;
        return true;
      }
      return false;
    };

    Statistics_Model.prototype.getNarrative = function() {
      return this._narrative;
    };

    Statistics_Model.prototype.setNarrative = function(val) {
      this._narrative = val;
      return this._narrativeChanged = true;
    };

    return Statistics_Model;

  })(BSS.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Written by Bryce Summers on 10.23.2017

    A model for a User Interface.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.UI_Model = (function(superClass) {
    extend(UI_Model, superClass);

    function UI_Model() {}

    UI_Model.prototype.buildModel = function() {};

    return UI_Model;

  })(BSS.Model);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Story Generator.
Written by Bryce Summers on Mar.27.2018.
Purpose: Encodes all of the information necessary to generate a story block.

The content cooresponds to story NAME blocks in a story file.

Allows for new story block elements to be instantiated. Generates instances, but leaves management to other 

 * FIXME: Change last_path to last_element. (Path, conditional)
 * FIXME: Revert to old state list on fork return, because who knows what has happened.
 */

(function() {
  BSS.Story_Generator = (function() {
    function Story_Generator(tokens) {
      this.tokens = tokens;
    }

    Story_Generator.prototype.newState = function(last_path, position, rotation_angle) {
      var state;
      state = {};
      state.path = last_path;
      state.normalized_path_length = 0;
      state.position = position;
      state.rotation_angle = rotation_angle;
      state.output = [];
      state.forked_state = null;
      state.conditional_function = null;
      state.character = null;
      state.index = 0;
      return state;
    };

    Story_Generator.prototype.copyState = function(state_in) {
      var out;
      out = {};
      out.path = state_in.path;
      out.normalized_path_length = state_in.normalized_path_length;
      out.position = state_in.position.clone();
      out.rotation_angle = state_in.rotation_angle;
      out.output = state_in.output;
      out.forked_state = state_in.forked_state;
      out.conditional_function = state_in.conditional_function;
      out.index = state_in.index;
      out.character = null;
      return out;
    };


    /*
    story MVP
    up 100
    narrate 1 The body is an accumulation of food.
    food 10
    food 20
    food 30
    food 40
    food 50
    food 60
    food 70
    food 80
    food 90
    the end
     */

    Story_Generator.prototype.generateElements = function(last_path, position, up_direction) {
      var forked_state, i, j, k, ref, ref1, rotation_angle, state, state_index, states, token_list;
      rotation_angle = Math.atan2(up_direction.y, up_direction.x);
      state = this.newState(last_path, position, rotation_angle);
      states = [state];
      for (i = j = 0, ref = this.tokens.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        token_list = this.tokens[i];
        if (token_list[0] === "introduce") {
          debugger;
          states = this.generateAgent(token_list, states);
          continue;
        }
        for (state_index = k = 0, ref1 = states.length; 0 <= ref1 ? k < ref1 : k > ref1; state_index = 0 <= ref1 ? ++k : --k) {
          state = states[state_index];
          state.token_list = token_list;
          state.type = token_list[0];
          if (state.type === "up" || state.type === "arc") {
            this.generatePath(state);
          }

          /*
          if state.type == "introduce"
              @generateAgent(state)
           */
          if (state.type === "narrate") {
            this.generateNarration(state);
          }
          if (state.type === "food") {
            this.generateOperator(state);
          }
          if (state.type === "fork") {
            if (state.forked_state === null) {
              this.generateConditional(state);
              state.forked_state = this.copyState(state);
            } else {
              forked_state = state.forked_state;
              state = this.copyState(forked_state);
              state.forked_state = forked_state;
              states[state_index] = state;
            }
            state.conditional_function = this.generateAgentConditionalFunction(token_list.slice(1));
          }
          if (state.type === "tell") {
            this.generateTellOperator(state);
          }
        }

        /*
        @update
        
        @linkPathsAndAddCharacters
        for i in [0...states.length - 1]
            state1 = states[i]
            state2 = states[i + 1]
            path_model1 = state1.path.getModel()
            path_model2 = state2.path.getModel()
        
             * Bidirectional link!
            path_model1.setRightLane(path_model2)
         */
      }
      return state.output;
    };

    Story_Generator.prototype.generatePath = function(state) {
      var angle, conditional, cx, cy, dir, dx, dy, factor, func, i, j, len, length, path_element, path_pline, pt, pt0, pt1, pts, px, py, radians_turned, radius_of_path, ref;
      if (state.type === "up") {
        dx = Math.cos(state.rotation_angle);
        dy = Math.sin(state.rotation_angle);
        length = state.token_list[1] * EX.style.file_to_screen_distance_factor;
        state.normalized_path_length = state.token_list[1];
        pt0 = state.position.clone();
        dir = new BDS.Point(dx, dy);
        pt1 = pt0.add(dir.multScalar(length));
        path_pline = new BDS.Polyline(false, [pt0, pt1]);
        path_element = new BSS.Path_Element(path_pline);
        state.position = pt1;
        state.output.push(path_element);
      } else if (state.type === "arc") {
        factor = 1;
        if (state.token_list[1] === "right") {
          factor = -1;
        }
        dx = Math.cos(state.rotation_angle - factor * Math.PI / 2);
        dy = Math.sin(state.rotation_angle - factor * Math.PI / 2);
        radius_of_path = EX.style.path_curvature_inverse + factor * EX.style.radius_path_default * state.index;
        cx = state.position.x + dx * radius_of_path;
        cy = state.position.y + dy * radius_of_path;
        pts = [];
        len = 100;
        radians_turned = factor * state.token_list[2] * Math.PI / 180;
        state.normalized_path_length = state.token_list[2];
        for (i = j = 0, ref = len; j <= ref; i = j += 1) {
          angle = state.rotation_angle + factor * Math.PI / 2 - i * 1.0 / len * radians_turned;
          px = cx + Math.cos(angle) * radius_of_path;
          py = cy + Math.sin(angle) * radius_of_path;
          pt = new BDS.Point(px, py);
          pts.push(pt);
        }
        path_pline = new BDS.Polyline(false, pts);
        path_element = new BSS.Path_Element(path_pline);
        state.output.push(path_element);
        state.position = pts[pts.length - 1];
        state.rotation_angle -= radians_turned;
      }
      if (state.character !== null) {
        path_element.addAgent(state.character);
        state.character = null;
      }
      if (state.conditional_function) {
        conditional = state.path;
        func = state.conditional_function;
        conditional.getModel().associateCondition(func, path_element.getModel());
        state.conditional_function = null;
      } else if (state.path !== null) {
        state.path.getModel().setDestination(path_element.getModel());
      }
      state.path = path_element;
    };

    Story_Generator.prototype.generateAgent = function(token_list, states) {
      var agent, agent_model, focus_agent, func, j, len1, s, state, token_index;
      token_index = 1;
      agent = new BSS.Agent_Element();
      agent_model = agent.getModel();
      if (token_list[token_index] === "left") {
        token_index += 1;
        if (token_list[token_index] === "companion") {
          token_index += 1;
          state = states[0];
          func = function(a) {
            return function(agent_model) {
              return agent_model.setLeftCompanion(a);
            };
          };
          this.addOperatorToPath(func(agent_model), state.normalized_path_length, state);
        }
        state = this.constructLeftState(states[0]);
        states = [state].concat(states);
      } else if (token_list[token_index] === "right") {
        token_index += 1;
        if (token_list[token_index] === "companion") {
          token_index += 1;
          state = states[states.length - 1];
          func = function(a) {
            return function(agent_model) {
              return agent_model.setRightCompanion(a);
            };
          };
          this.addOperatorToPath(func(agent_model), state.normalized_path_length, state);
        }
        state = this.constructRightState(states[states.length - 1]);
        states.push(state);
      } else {
        for (j = 0, len1 = states.length; j < len1; j++) {
          s = states[j];
          if (s.index === 0) {
            state = s;
            break;
          }
        }
      }
      focus_agent = false;
      if (token_list[token_index] === "protagonist") {
        focus_agent = true;
        token_index += 1;
      }
      agent_model.setCharacterType(token_list[token_index], focus_agent);
      state.output.push(agent);
      state.character = agent;
      return states;
    };

    Story_Generator.prototype.constructRightState = function(state) {
      var lane_pos, loc, offset, out, path, ref, right, up;
      path = state.path;
      ref = path.getLocation(1.0), loc = ref[0], up = ref[1];
      right = new BDS.Point(-up.y, up.x);
      offset = path.getCrossSectionRadius();
      lane_pos = loc.add(right.multScalar(offset));
      out = this.newState(null, lane_pos, state.rotation_angle);
      out.index = state.index + 1;
      out.output = state.output;
      return out;
    };

    Story_Generator.prototype.constructLeftState = function(state) {
      var lane_pos, left, loc, offset, out, path, ref, up;
      path = state.path;
      ref = path.getLocation(1.0), loc = ref[0], up = ref[1];
      left = new BDS.Point(up.y, -up.x);
      offset = path.getCrossSectionRadius();
      lane_pos = loc.add(left.multScalar(offset));
      out = this.newState(null, lane_pos, state.rotation_angle);
      out.index = state.index - 1;
      out.output = state.output;
      return out;
    };

    Story_Generator.prototype.generateNarration = function(state) {
      var func, i, j, message, normalized_dist, ref, str;
      normalized_dist = state.token_list[1];
      message = "";
      for (i = j = 2, ref = state.token_list.length; j < ref; i = j += 1) {
        str = state.token_list[i];
        message = message + " " + str;
      }
      console.log(message);
      func = function(agent_model) {
        return agent_model.statistics.setNarrative(message);
      };
      this.addOperatorToPath(func, normalized_dist, state);
    };

    Story_Generator.prototype.generateOperator = function(state) {
      var func, normalized_dist;
      normalized_dist = state.token_list[1];
      if (state.token_list[0] === "food") {
        func = function(agent_model) {
          var food;
          food = agent_model.statistics.getFood();
          return agent_model.statistics.setFood(food + 1);
        };
      }
      this.addOperatorToPath(func, normalized_dist, state);
    };

    Story_Generator.prototype.addOperatorToPath = function(func, normalized_distance, state) {
      var operator, percentage;
      percentage = normalized_distance / state.normalized_path_length;
      operator = new BSS.Operator_Element();
      operator.setFunction(func);
      state.path.addOperator(operator, percentage);
      state.output.push(operator);
    };

    Story_Generator.prototype.generateTellOperator = function(state) {
      var model, operator, percentage;
      percentage = .99;
      operator = new BSS.Operator_Element();
      model = operator.getModel();
      model.setType("story_load");
      model.setState("story_name", state.token_list[1]);
      model.setState("path", state.path);
      state.path.addOperator(operator, percentage);
      return state.output.push(operator);
    };

    Story_Generator.prototype.generateConditional = function(state) {
      var conditional;
      conditional = new BSS.Condition_Element();
      state.path.getModel().setDestination(conditional.getModel());
      state.path = conditional;
      return state.output.push(conditional);
    };

    Story_Generator.prototype.generateAgentConditionalFunction = function(token_list) {
      return function(agent_model) {
        var val1, val2;
        val1 = agent_model.lookupKey(token_list[0]);
        val2 = token_list[2];
        while (val1 === "follow") {
          agent_model = agent_model.leader;
          val1 = agent_model.lookupKey(token_list[0]);
        }
        return val1 === val2;
      };
    };

    return Story_Generator;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Story loader class.

Written by Bryce Summers on Mar.27.2018.
Purpose: creates a named set of story generators from the given text file.
 */

(function() {
  BSS.Story_Loader = (function() {
    function Story_Loader(place) {
      this.place = place;
      this.shouldRemoveEOL = false;
    }

    Story_Loader.prototype.load_story = function(file_name) {

      /*
      Read File.
      perform rest of the operations asynchronously when the file loads.
      place will be created then.
       */
      return this.readFile(file_name);
    };

    Story_Loader.prototype.readFile = function(file_name) {
      var rawFile;
      rawFile = new XMLHttpRequest();
      rawFile.open("GET", file_name, true);
      rawFile.storyLoader = this;
      rawFile.onreadystatechange = function() {
        var allText;
        if (rawFile.readyState === 4) {
          if (rawFile.status === 200 || rawFile.status === 0) {
            allText = rawFile.responseText;
            return this.storyLoader.createStories(allText);
          }
        }
      };
      rawFile.send(null);
    };


    /*
       Break lines.
       Break stories.
       Tokenize.
     */

    Story_Loader.prototype.createStories = function(text) {
      var block_end_indices, block_lines, block_start_indices, i, index, index_end, index_start, j, k, l, line, lines, map, name, ref, ref1, ref2, ref3, start_name, storyGenerator;
      console.log(text);
      text = text.replace("\t", " ");
      lines = text.split("\n");
      block_start_indices = [];
      block_end_indices = [];
      for (i = j = 0, ref = lines.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        line = lines[i];
        line = line.split(" ");
        line = this.filter(line, "");
        if (this.shouldRemoveEOL && i < lines.length - 1) {
          line = this.removeEOL(line);
        }
        if (line[0] === "story") {
          block_start_indices.push(i);
        }
        if (line[0] === "the" && line[1] === "end") {
          block_end_indices.push(i);
        }
        lines[i] = line;
      }
      if (block_start_indices.length !== block_end_indices.length) {
        this.shouldRemoveEOL = true;
        this.createStories(text);
        return;
        throw new Error("Syntax error in start and ends of blocks.");
      }
      map = {};
      start_name = name = lines[0][1];
      for (i = k = 0, ref1 = block_start_indices.length; k < ref1; i = k += 1) {
        index_start = block_start_indices[i];
        index_end = block_end_indices[i];
        block_lines = [];
        for (index = l = ref2 = index_start, ref3 = index_end; l <= ref3; index = l += 1) {
          line = lines[index];
          block_lines.push(line);
        }
        storyGenerator = new BSS.Story_Generator(block_lines);
        name = block_lines[0][1];
        map[name] = storyGenerator;
        if (name === start_name) {
          map.start = storyGenerator;
        }
      }
      this.place.setStoryMap(map);
    };

    Story_Loader.prototype.filter = function(array, item) {
      var elem, j, len1, output;
      output = [];
      for (j = 0, len1 = array.length; j < len1; j++) {
        elem = array[j];
        if (elem !== item) {
          output.push(elem);
        }
      }
      return output;
    };

    Story_Loader.prototype.removeEOL = function(line) {
      var eol, last_char, len;
      if (line.length < 1) {
        return line;
      }
      eol = line[line.length - 1];
      len = eol.length;
      if (len < 2) {
        return line;
      }
      last_char = eol[len - 1];
      eol = eol.substring(0, len - 1);
      line[line.length - 1] = eol;
      return line;
    };

    return Story_Loader;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
This is a test place, it initializes the MVP story to test functionality, before the writing of the compiler.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Test_Place = (function(superClass) {
    extend(Test_Place, superClass);

    function Test_Place(scene) {
      var storyLoader, story_map;
      Test_Place.__super__.constructor.call(this, scene);
      storyLoader = new BSS.Story_Loader(this);
      story_map = storyLoader.load_story('assets/stories/004_friends.txt');
      this.init_scene_ui();
    }

    Test_Place.prototype.init_place = function() {
      var first_path, i, j, k, operator, path_element, path_pline, player_character, pt0, pt1, pts, x, y, y0, y1;
      pts = [];
      x = 0;
      y = 0;
      first_path = null;
      for (i = j = 0; j < 1; i = ++j) {
        x = 0;
        y0 = i * 50;
        y1 = y0 + 300;
        pt0 = new BDS.Point(x, y0);
        pt1 = new BDS.Point(x, y1);
        path_pline = new BDS.Polyline(false, [pt0, pt1]);
        path_element = new BSS.Path_Element(path_pline);
        if (first_path === null) {
          first_path = path_element;
        }
        this.addPath(path_element);
      }
      for (i = k = 1; k <= 9; i = ++k) {
        operator = new BSS.Operator_Element();
        operator.setFunction(function(agent_model) {
          var food;
          food = agent_model.statistics.getFood();
          return agent_model.statistics.setFood(food + 1);
        });
        path_element.addOperator(operator, i * 1.0 / 10);
        this.addOperator(operator);
      }
      operator = new BSS.Operator_Element();
      operator.setFunction(function(agent_model) {
        return agent_model.statistics.setNarrative("The body is an accumulation of food.");
      });
      path_element.addOperator(operator, .001);
      this.addOperator(operator);
      player_character = new BSS.Agent_Element();
      first_path.addAgent(player_character);
      this.addAgent(player_character);
      this.scene.setFocusAgent(player_character);
      return this.scene.setFocusPlace(this);
    };

    Test_Place.prototype.init_scene_ui = function() {
      var h, label_h, p0, p1, p2, p3, pLine, ref, textbox_params, ui, ui_elements, w;
      ref = this.scene.getUI(), ui = ref[0], ui_elements = ref[1];
      w = 1200;
      h = 800;
      label_h = 50;
      p0 = new BDS.Point(w / 4, h - label_h);
      p1 = new BDS.Point(w * 3 / 4, h - label_h);
      p2 = new BDS.Point(w * 3 / 4, h);
      p3 = new BDS.Point(w / 4, h);
      pLine = new BDS.Polyline(false, [p0, p1, p2, p3]);
      textbox_params = {
        fill: EX.style.c_building_fill,
        area: pLine,
        textx: w / 4,
        texty: h,
        str: "Food becomes the body."
      };
      ui_elements.textbox = ui.createLabel(textbox_params);
      p0 = new BDS.Point(0, h - label_h);
      p1 = new BDS.Point(w / 4, h - label_h);
      p2 = new BDS.Point(w / 4, h);
      p3 = new BDS.Point(0, h);
      pLine = new BDS.Polyline(false, [p0, p1, p2, p3]);
      textbox_params = {
        fill: EX.style.c_building_fill,
        area: pLine,
        textx: p3.x,
        texty: p3.y,
        str: EX.style.resource_name_food + "0"
      };
      return ui_elements.foodbox = ui.createLabel(textbox_params);
    };

    return Test_Place;

  })(BSS.Place_Element);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Representation Interface class.
 *
 * Written by Bryce Summers on 10.23.2017
 *
 * Specifies the capabilities of all visual representations.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BSS.Representation = (function(superClass) {
    extend(Representation, superClass);

    function Representation() {}

    return Representation;

  })(THREE.Object3D);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Auditory Rerpresentation.

Written by Bryce Summers.

Handles representation and plaback of audio clips and synthesis.
 */

(function() {
  BSS.Audio_Representation = (function() {
    function Audio_Representation() {}

    return Audio_Representation;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Collision Representation Class.
 *
 * Written by Bryce Summers on 10.23.2017
 *
 * Represents a node in a collision geometry hiearchy, 
 * handles the management of a BVH and cooresponding areas.
 *
 * Usage: Configure, Build, Query.
 *
 */

(function() {
  BSS.Collision_Representation = (function() {
    function Collision_Representation() {
      this._bvh = new BDS.BVH2D();
      this._bounding_area = null;
    }


    /*
    
    Configuration.
     */

    Collision_Representation.prototype.addCollisionAreas = function(areas) {
      var anArea, i, len, results;
      results = [];
      for (i = 0, len = areas.length; i < len; i++) {
        anArea = areas[i];
        results.push(this.addCollisionArea(anArea));
      }
      return results;
    };

    Collision_Representation.prototype.addCollisionArea = function(area) {
      return this._bvh.add(area);
    };

    Collision_Representation.prototype.removeCollisionAreas = function(areas) {
      var anArea, i, len, results;
      results = [];
      for (i = 0, len = areas.length; i < len; i++) {
        anArea = areas[i];
        results.push(this.removeCollisionArea(anArea));
      }
      return results;
    };

    Collision_Representation.prototype.removeCollisionarea = function(area) {
      return this._bvh.remove(area);
    };


    /*
    
    Build
     */

    Collision_Representation.prototype.build = function() {
      return this.buildBoundingArea();
    };

    Collision_Representation.prototype.buildBoundingArea = function() {
      this._collision_area = this._bvh.toBoundingBox().toPolyline();
      this._collision_area.setAssociatedData(this);
      return this._collision_area;
    };


    /*
    
    Query.
     */

    Collision_Representation.prototype.getBoundingArea = function() {
      if (this._collision_area === null) {
        this.generateCollisionArea();
      }
      return this._collision_area;
    };

    Collision_Representation.prototype.containsPt = function(pt) {
      return this._bvh.query_point(pt) !== null;
    };

    return Collision_Representation;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Written on Oct.07.2017 by Bryce Summers
Purpose: Creates THREE.js paths.
 */

(function() {
  EX.Path_Visual_Factory = (function() {
    function Path_Visual_Factory(polyline, width, color, show_outline) {
      this.vecs = this._BDS_Polyline_to_THREE_vertex_list(polyline);
      this.width = width;
      this.color = color;
      this.spline = new THREE.CatmullRomCurve3(this.vecs);
      this.curve = new BDS.Curve(this.spline);
      this.show_outline = show_outline;
    }

    Path_Visual_Factory.prototype.getPathVisual = function() {
      return this.getVisual(1, this.curve, this.width, this.color);
    };

    Path_Visual_Factory.prototype.getVisual = function(max_length, curve, width, color) {
      var fill, fill_geometry, fill_material, fill_mesh, left_line, material, middle_material, offset_amount, output, right_line, times_left, times_right, verts_left, verts_right;
      offset_amount = width / 2;
      curve.updateDiscretization(max_length);
      material = EX.style.m_default_line.clone();
      material.color = EX.style.c_default_line;
      middle_material = EX.style.m_default_line.clone();
      middle_material.color = EX.style.c_default_line;

      /*
      middle_line = new THREE.Geometry()
      middle_line.vertices = curve.getDiscretization()
       */
      times_left = [];
      times_right = [];
      verts_left = [];
      verts_right = [];
      left_line = new THREE.Geometry();
      verts_left = curve.getOffsets(max_length, offset_amount, times_left);
      left_line.vertices = verts_left;
      right_line = new THREE.Geometry();
      verts_right = curve.getOffsets(max_length, -offset_amount, times_right);
      right_line.vertices = verts_right;
      fill_geometry = this._get_fill_geometry(verts_left, verts_right, times_left, times_right);
      fill_material = EX.style.m_flat_fill.clone();
      fill_material.color = color;
      this.fill_material = fill_material;
      output = new THREE.Object3D();
      fill = new THREE.Object3D();
      output.add(fill);
      fill_mesh = new THREE.Mesh(fill_geometry, fill_material);
      fill_mesh.position.z = -.01;
      output.add(fill_mesh);
      if (this.show_outline) {
        output.add(new THREE.Line(left_line, material));
        output.add(new THREE.Line(right_line, material));
      }
      return output;
    };

    Path_Visual_Factory.prototype._get_fill_geometry = function(left_verts, right_verts, times_left, times_right) {
      var big_left, face, faces, l_index, l_len, l_time, left_time, output, r_index, r_len, r_time, right_time;
      output = new THREE.Geometry();
      output.vertices = left_verts.concat(right_verts);
      faces = output.faces;
      l_len = left_verts.length;
      r_len = right_verts.length;
      l_index = 0;
      r_index = 0;
      l_time = 0.0;
      r_time = 0.0;
      while (l_index < l_len - 1 || r_index < r_len - 1) {
        left_time = times_left[l_index];
        right_time = times_right[r_index];
        big_left = false;
        big_left = left_time < right_time;
        if (left_time === right_time) {
          big_left = times_left[l_index + 1] < times_right[r_index + 1];
        }
        if (big_left) {
          face = new THREE.Face3(l_index, l_index + 1, r_index + l_len);
          faces.push(face);
          l_index += 1;
          continue;
        }
        face = new THREE.Face3(r_index + 1 + l_len, r_index + l_len, l_index);
        faces.push(face);
        r_index += 1;
        continue;
      }
      return output;
    };

    Path_Visual_Factory.prototype._BDS_Polyline_to_THREE_vertex_list = function(polyline) {
      var i, len, pt, pts, vec, vecs;
      pts = polyline.toPoints();
      vecs = [];
      for (i = 0, len = pts.length; i < len; i++) {
        pt = pts[i];
        vec = new THREE.Vector3(pt.x, pt.y, pt.z);
        vecs.push(vec);
      }
      if (polyline.isClosed()) {
        pt = pts[0];
        vecs.push(new THREE.Vector3(pt.x, pt.y, pt.z));
        pt = pts[1];
        vecs.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      return vecs;
    };

    Path_Visual_Factory.prototype._THREE_vertex_list_to_BDS_Polyline = function(vectors) {
      var i, len, out, vec;
      out = new BDS.Polyline();
      for (i = 0, len = vectors.length; i < len; i++) {
        vec = vectors[i];
        out.addPoint(new BDS.Point(vec.x, vec.y));
      }
      return out;
    };

    return Path_Visual_Factory;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Global Style objects, including materials for roads, lines, etc.
 *
 * Written by Bryce Summers on 12 - 19 - 2016.
 *
 */

(function() {
  EX.init_style = function() {
    EX.style = {
      resource_name_food: "Food: ",
      radius_path_default: 50,
      radius_operator_default: 10,
      radius_agent_default: 20,
      file_to_screen_distance_factor: 8,
      path_curvature_inverse: 100,
      radius_road_local: 50,
      radius_road_collector: 75,
      radius_road_artery: 100,
      discretization_length: 10,
      road_offset_amount: 10,
      user_input_min_move: 10,
      m_default_fill: new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide
      }),
      m_default_line: new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 5
      }),
      m_flat_fill: new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        side: THREE.DoubleSide
      }),
      c_building_fill: new THREE.Color(0xaaaaaa),
      c_building_outline: new THREE.Color(0x000000),
      c_car_fill: new THREE.Color(0x00aaaa),
      c_road_fill: new THREE.Color(0x888888),
      c_road_midline: new THREE.Color(0x514802),
      c_road_outline: new THREE.Color(0x000000),
      c_operator_fill: new THREE.Color(0xbbbbbb),
      c_default_line: new THREE.Color(0x000000),
      AABB_testing_material: new THREE.LineBasicMaterial({
        color: 0x0000ff
      }),
      cursor_circle_radius: 10,
      cursor_circle_z: 1,
      cursor_circle_color: new THREE.Color(0xff0000),
      dz_intersection: 0.01,
      dz_road: 0,
      dz_cars: .02,
      highlight: new THREE.Color(0x0000ff),
      error: new THREE.Color(0xff0000),
      action: new THREE.Color(0x72E261),
      c_normal: new THREE.Color(0xdddddd)
    };
    EX.style.fontLoader = new THREE.FontLoader();
    return EX.style.fontLoader.load('assets/fonts/Raleway_Regular.typeface.json', function(font) {
      var i, len, params, ref, results;
      EX.style.font = font;
      ref = EX.Visual_Factory.textMeshQueue;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        params = ref[i];
        results.push(EX.Visual_Factory.newText(params));
      }
      return results;
    });
  };

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Written by Bryce Summers on 10.23.2017
 * 
 * Allows THREE.js visuals to be built from polylines, polygons, strings, etc.
 */

(function() {
  EX.Visual_Factory = (function() {
    function Visual_Factory() {
      EX.Visual_Factory.unit_meshes = new EX.Unit_Meshes();
    }


    /*
         * Local Variables.
    
         * Root of THREE.JS visualization.
        @scene = new THREE.Scene()
        
         * Simple Meshes, such as circles creator.
        @unit_meshes = new BDS.Unit_Meshes(EX.style.m_flat_fill, EX.style.m_flat_fill, EX.style.m_default_line)
    
        #@init_test_scene()
        @input_root = null
    
        @init_test_bryce_image()
    
    init_test_scene: () ->
    
         * Test Line on the screen.
        pts = [new BDS.Point(0, 0), new BDS.Point(100, 100), new BDS.Point(500, 100)]
        polyline = new BDS.Polyline(false, pts)
        @newCurve(polyline, new THREE.Color(0, 0, 0))
    
         * Test a path on screen.
        pts = [new BDS.Point(0, 200), new BDS.Point(100, 300), new BDS.Point(500, 300)]
        polyline = new BDS.Polyline(false, pts)
        @newPath(polyline, 50, new THREE.Color(1, 0, 0))
    
         * Test a path on screen.
        pts = [new BDS.Point(500, 500), new BDS.Point(600, 500), new BDS.Point(550, 700)]
        polyline = new BDS.Polyline(false, pts)
        @newPolygon(polyline, 50, new THREE.Color(0, 0, 1))
        @newPoint(new BDS.Point(800, 350), new THREE.Color(0, 0, 1))
     */

    Visual_Factory.unit_meshes = null;

    Visual_Factory.textMeshQueue = [];

    Visual_Factory.textureLoader = new THREE.TextureLoader();

    Visual_Factory.newCurve = function(polyline, color) {
      var geom, k, len, line_material, mesh, pt, pts;
      if (polyline.size() < 2) {
        return;
      }
      geom = new THREE.Geometry();
      pts = polyline.toPoints();
      if (polyline.isClosed()) {
        pts.push(pts[0]);
      }
      for (k = 0, len = pts.length; k < len; k++) {
        pt = pts[k];
        geom.vertices.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      line_material = EX.style.m_default_line.clone();
      line_material.color = color.clone();
      mesh = new THREE.Line(geom, line_material);
      return mesh;
    };

    Visual_Factory.newPath = function(polyline, width, color, show_outline) {
      var mesh, pathFactory;
      if (!show_outline) {
        show_outline = false;
      }
      if (polyline.size() < 2 || (polyline.isClosed() && polyline.size < 3)) {
        return null;
      }
      pathFactory = new EX.Path_Visual_Factory(polyline, width, color, show_outline);
      mesh = pathFactory.getPathVisual();
      return mesh;
    };

    Visual_Factory.newPolygon = function(polygon, color) {
      var geometry, k, len, material, mesh, pt, pts, shape, vecs;
      pts = polygon.toPoints();
      vecs = [];
      for (k = 0, len = pts.length; k < len; k++) {
        pt = pts[k];
        vecs.push(new THREE.Vector3(pt.x, pt.y, pt.z));
      }
      shape = new THREE.Shape(vecs);
      geometry = new THREE.ShapeGeometry(shape);
      material = EX.style.m_flat_fill.clone();
      mesh = new THREE.Mesh(geometry, material);
      return mesh;
    };

    Visual_Factory.newPoint = function(pt, color, radius) {
      var material, mesh, pos, scale;
      scale = new THREE.Vector3(radius, radius, 1);
      pos = new THREE.Vector3(pt.x, pt.y, 0);
      material = EX.style.m_flat_fill.clone();
      mesh = this.unit_meshes.newCircle({
        color: color,
        material: material,
        position: pos,
        scale: scale
      });
      return mesh;
    };


    /*
    
    External API.
     */

    Visual_Factory.setInputRoot = function(input) {
      var input_root;
      return input_root = input;
    };

    Visual_Factory.getVisual = function() {
      return this.scene;
    };

    Visual_Factory.new_label = function(str) {
      var obj, params;
      obj = new THREE.Object3D();
      params = {
        font: EX.style.fontLoader,
        message: str,
        height: 20,
        out: obj,
        fill_color: 0x000000,
        outline_color: 0x111111
      };
      EX.Visual_Factory.newText(params);
      obj.position.copy(new THREE.Vector3(-50, 20, -100));
      obj.scale.copy(new THREE.Vector3(1, -1, 1));
      obj.rotation.copy(new THREE.Vector3(0, 0, Math.PI / 2));
      return obj;
    };


    /*
    EX.style.load_texture = (url) ->
        material = new THREE.MeshBasicMaterial( {
            map: null
         } );
    
        loader = new THREE.TextureLoader();
    
         * load the resource
        loader.load(
            url,
            (texture) ->
                 * Color map the material to the loaded texture.
                material.map = texture
    
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set( 40, 40);
            ,
            (xhr) ->
                console.log( (xhr.loaded / xhr.total * 100) + '% loaded' )
            ,
             * Function called when download errors
            ( xhr ) ->
                console.log( "The texture at url: " + url + "  was not loaded." )
        )
    
        return material
     */

    Visual_Factory.newSprite = function(url, dim) {
      var container, geom, mat, mesh, texture;
      texture = EX.Visual_Factory.textureLoader.load(url);
      geom = new THREE.PlaneBufferGeometry(dim.w, dim.h, 32);
      mat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
        map: texture,
        transparent: true
      });
      mesh = new THREE.Mesh(geom, mat);
      mesh.position.x = dim.w / 2;
      mesh.position.y = dim.h / 2;
      mesh.rotation.z = Math.PI;
      mesh.scale.x = -1;
      container = new THREE.Object3D();
      container.add(mesh);
      container.position.x = dim.x;
      container.position.y = dim.y;
      return container;
    };

    Visual_Factory.newText = function(params) {
      var geometry, message, shapes;
      if (!EX.style.font) {
        EX.Visual_Factory.textMeshQueue.push(params);
        return;
      }
      if (params.fill_color || params.outline_color) {
        message = params.message;
        shapes = EX.style.font.generateShapes(message, params.height, 2);
        geometry = new THREE.ShapeGeometry(shapes);
        geometry.computeBoundingBox();
      }
      if (params.fill_color) {
        EX.Visual_Factory.newFillText(params, shapes, geometry);
      }
      if (params.outline_color) {
        EX.Visual_Factory.newOutlineText(params, shapes, geometry);
      }
      return params.out.position.z = +.1;
    };

    Visual_Factory.newFillText = function(params, shapes, geometry) {
      var color_fill, material_fill, output, text, textShape, tx, xMid;
      output = params.out;
      textShape = new THREE.BufferGeometry();
      color_fill = params.fill_color;
      material_fill = new THREE.LineBasicMaterial({
        color: color_fill,
        side: THREE.DoubleSide
      });
      xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      tx = 0;
      if (params.align_center) {
        tx = xMid;
      }
      geometry.translate(tx, params.height, 0);
      textShape.fromGeometry(geometry);
      text = new THREE.Mesh(textShape, material_fill);
      return output.add(text);
    };

    Visual_Factory.newOutlineText = function(params, shapes, geometry) {
      var color_outline, hole, holeShapes, i, j, k, l, lineGeometry, lineMesh, lineText, m, material_outline, output, ref, ref1, ref2, shape, tx;
      output = params.out;
      color_outline = params.outline_color;
      material_outline = new THREE.MeshBasicMaterial({
        color: color_outline,

        /*
        transparent: true,
        opacity: 1.0,
        FIXME: Specify Opacity settings.
         */
        side: THREE.DoubleSide
      });
      holeShapes = [];
      for (i = k = 0, ref = shapes.length; k < ref; i = k += 1) {
        shape = shapes[i];
        if (shape.holes && shape.holes.length > 0) {
          for (j = l = 0, ref1 = shape.holes.length; l < ref1; j = l += 1) {
            hole = shape.holes[j];
            holeShapes.push(hole);
          }
        }
      }
      shapes.push.apply(shapes, holeShapes);
      lineText = new THREE.Object3D();
      params.out.position.z = +.1;
      tx = 0;
      if (params.align_center) {
        tx = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      }
      for (i = m = 0, ref2 = shapes.length; m < ref2; i = m += 1) {
        shape = shapes[i];
        lineGeometry = shape.createPointsGeometry();
        lineGeometry.translate(tx, params.height, 0);
        lineMesh = new THREE.Line(lineGeometry, material_outline);
        lineText.add(lineMesh);
      }
      output.add(lineText);
    };

    return Visual_Factory;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 *
 * Visual Representation.
 *
 * Adapted by Bryce Summers on 10.26.2017
 *
 * Handles the management of a visual representation.
 *
 *
 * Usage: Configure, Build, {Convert, Render, Mutate}.
 */

(function() {
  BSS.Visual_Representation = (function() {
    function Visual_Representation() {
      this._obj3D = new THREE.Object3D();
      this._children = new Set();
    }


    /*
    
    Configure
     */

    Visual_Representation.prototype.addVisual = function(visual) {
      this._obj3D.add(visual);
      return this._children.add(visual);
    };

    Visual_Representation.prototype.removeVisual = function(visual) {
      this._obj3D.remove(visual);
      return this._children["delete"](visual);
    };

    Visual_Representation.prototype.getVisual = function() {
      return this._obj3D;
    };

    Visual_Representation.prototype.clearVisuals = function() {
      this._children.forEach((function(_this) {
        return function(visual) {
          return _this._obj3D.remove(visual);
        };
      })(this));
      return this._children = new Set();
    };

    Visual_Representation.prototype.setCameraobj3D = function(obj3D) {};

    Visual_Representation.prototype.setPosition = function(position) {
      var z;
      z = this._obj3D.position.z;
      this._obj3D.position.copy(position.clone());
      return this._obj3D.position.z = z;
    };

    Visual_Representation.prototype.getPosition = function() {
      return this._obj3D.position.clone();
    };

    Visual_Representation.prototype.setRotation = function(rotation_z) {
      return this._obj3D.rotation.z = rotation_z;
    };

    Visual_Representation.prototype.getRotation = function() {
      return this._obj3D.rotation.z;
    };

    Visual_Representation.prototype.setUpDirection = function(up) {
      var angle;
      up = up.normalize();
      angle = Math.atan2(up.y, up.x) + Math.PI / 2;
      return this.setRotation(angle);
    };

    Visual_Representation.prototype.setScale = function(scale) {
      return this._obj3D.scale.copy(scale.clone());
    };

    Visual_Representation.prototype.getScale = function() {
      return this._obj3D.scale.clone();
    };


    /*
    
    Conversion to other forms.
     */

    Visual_Representation.prototype.build = function() {};

    Visual_Representation.prototype.toCollisionAreas = function(output) {
      var a, b, c, face, faces, geometry, i, j, len, len1, localToWorld, mesh, mesh_list, obj, polyline, polyline_list, vertices;
      obj = this._obj3D;
      mesh_list = this._to_mesh_list(obj);
      polyline_list = [];
      if (output !== void 0) {
        polyline_list = output;
      }
      for (i = 0, len = mesh_list.length; i < len; i++) {
        mesh = mesh_list[i];
        geometry = mesh.geometry;
        vertices = geometry.vertices;
        faces = geometry.faces;
        localToWorld = mesh.matrixWorld;
        for (j = 0, len1 = faces.length; j < len1; j++) {
          face = faces[j];
          a = vertices[face.a].clone();
          b = vertices[face.b].clone();
          c = vertices[face.c].clone();
          a.applyMatrix4(localToWorld);
          b.applyMatrix4(localToWorld);
          c.applyMatrix4(localToWorld);
          a = this._vector_to_point(a);
          b = this._vector_to_point(b);
          c = this._vector_to_point(c);
          polyline = new BDS.Polyline(true, [a, b, c]);
          polyline.setAssociatedData(this);
          polyline_list.push(polyline);
        }
      }
      return polyline_list;
    };

    Visual_Representation.prototype._vector_to_point = function(vec) {
      return new BDS.Point(vec.x, vec.y, vec.z);
    };

    Visual_Representation.prototype._to_mesh_list = function(obj) {
      var add_output, output;
      output = [];
      add_output = function(o) {
        if (o.geometry) {
          return output.push(o);
        }
      };
      obj.traverse(add_output);
      return output;
    };

    return Visual_Representation;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Testing Routines.
 *
 * Written by Bryce Summers
 */

(function() {
  EX.Testing = (function() {
    function Testing() {}

    return Testing;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Overlays
    Written by Bryce on May.4.2017
    Adapted by Bryce Summers on Mar.22.2018
    
    Purpose: This class provides functions for mapping visual data displays across the screen.
        It also provides functions for producing custom sized geometries.
        - produce overlays.
        - Reset the screen to the normal aesthetic.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.Overlay_Element = (function(superClass) {
    extend(Overlay_Element, superClass);

    function Overlay_Element() {
      var view;
      Overlay_Element.__super__.constructor.call(this);
      view = this.getVisual();
    }

    Overlay_Element.prototype.createRectangle = function(params) {
      var rect;
      rect = TSAG.style.unit_meshes.newSquare({
        color: new THREE.Color(params.fill)
      });
      rect.scale.x = params.w;
      rect.scale.y = params.h;
      rect.position.x = params.x + params.w / 2;
      rect.position.y = params.y + params.h / 2;
      rect.position.z = params.depth;
      return rect;
    };

    Overlay_Element.prototype.addPermanentVisual = function(mesh) {
      var view;
      view = this.getVisual();
      return view.add(mesh);
    };

    return Overlay_Element;

  })(BSS.Element);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    User Interface Layer class. Represents a single layer of user interface elements.
    Written by Bryce on May.4.2017
    Adapted by Bryce Summers on Mar.22.2018
    
    Purpose: This class provide general functions for the operation of UI's.
        - static visual generation.
        - creation and deletion of buttons.

    This class also handles the text based display of information to the users.

    This class internally manages the visualization, querying, and management of label objects.
    It returns reference objects that can be used to instruct this class to perform modifications.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.UI = (function(superClass) {
    extend(UI, superClass);

    function UI(z_depth) {
      UI.__super__.constructor.call(this, new BSS.Model());
      this._bvh = new BDS.BVH2D([]);
      this._elements = new Set();
      this._c_resting = new THREE.Color(0xe6dada);
      this.z_depth = z_depth;
    }


    /*
    Labels: They sit on screen with a text visual object underneath.
     */

    UI.prototype.createLabel = function(params) {
      var background_visual, container_visual, element, text_visual;
      container_visual = new THREE.Object3D();
      background_visual = EX.Visual_Factory.newPolygon(params.area, params.fill);
      container_visual.add(background_visual);
      text_visual = EX.Visual_Factory.new_label(params.str);
      text_visual.position.x = params.textx;
      text_visual.position.y = params.texty;
      container_visual.add(text_visual);
      element = {
        area: params.area,
        visual: container_visual,
        text_visual: text_visual,
        background_visual: background_visual,
        str: params.str,
        fill: params.fill,
        textx: params.textx,
        texty: params.texty
      };
      element.area.setAssociatedData(element);
      this._bvh.add(element.area);
      this._elements.add(element);
      this.getVisualRepresentation().addVisual(container_visual);
      return element;
    };

    UI.prototype.updateLabel = function(element, params) {
      var container, text_visual;
      if (params.update_str) {
        container = element.visual;
        container.remove(element.text_visual);
        text_visual = this._newTextVisual(element);
        container.add(text_visual);
        return element.text_visual = text_visual;
      }
    };

    UI.prototype._newTextVisual = function(params) {
      var text_visual;
      text_visual = EX.Visual_Factory.new_label(params.str);
      text_visual.position.x = params.textx;
      text_visual.position.y = params.texty;
      text_visual.position.z = this.z_depth + .01;
      return text_visual;
    };

    UI.prototype.createButton = function(area, material, click_function) {

      /*
       * An element is an associative object of the following form:
       * {click:    () -> what happens when the user clicks on this element.
       *  polyline: A polyline representing the collision detection region for the object.
       *  material: a pointer to the material object responsible for filling the actual
       *  object on the screen, such as with an associated image base texture map.
       */
      var element;
      material.color = this._c_resting;
      element = {
        click: click_function,
        polyline: area,
        material: material
      };
      element.polyline.setAssociatedData(element);
      this._bvh.add(element.polyline);
      this._elements.add(element);
      return element;
    };

    UI.prototype.removeButton = function(b) {
      var a;
      a = this._elements["delete"](b);
      b = this._bvh.remove(b.polyline);
      return a && b;
    };

    UI.prototype.query_point = function(pt) {
      return this._bvh.query_point(pt);
    };


    /*
    
    Internal Helper functions.
     */

    UI.prototype._createRectangle = function(params) {
      var rect;
      rect = TSAG.style.unit_meshes.newSquare({
        color: new THREE.Color(params.fill)
      });
      rect.scale.x = params.w;
      rect.scale.y = params.h;
      rect.position.x = params.x + params.w / 2;
      rect.position.y = params.y + params.h / 2;
      rect.position.z = params.depth;
      return rect;

      /*
      mesh.scale.x = 200
      mesh.scale.y = 200
      
      
      view.add(mesh)
      
      window.mesh = mesh
       */

      /*
      @controller_build_road = 
      @controller_build_road.setActive(false)
      @controller_demolish_road = 
      @controller_demolish_road.setActive(false)
       */

      /*
       * -- Tools UI Buttons.
      b1 = new BDS.Box(new BDS.Point(0,   0),
                       new BDS.Point(64, 64));
      
      b2 = new BDS.Box(new BDS.Point(64,   0),
                       new BDS.Point(128, 64));
      
      b3 = new BDS.Box(new BDS.Point(128,  0),
                       new BDS.Point(192, 64));
      
      p1 = b1.toPolyline()
      p2 = b2.toPolyline()
      
       * Modification functions.
      func_build_road_local     = () ->
          mode = TSAG.I_Mouse_Build_Road.mode_local
          @controller_build_road.setMode(mode)
      
      func_build_road_collector = () ->
          mode = TSAG.I_Mouse_Build_Road.mode_collector
          @controller_build_road.setMode(mode)
      
      func_build_road_artery    = () ->
          mode = TSAG.I_Mouse_Build_Road.mode_artery
          @controller_build_road.setMode(mode)
      
      img_build_road_local     = null # Load Local road building image.
      img_build_road_collector = null # Load Collector road building image.
      img_build_road_artery    = null # Load Arterial road building image.
      
      @controller_ui.createButton(p1, func_build_road_local,     img_build_road_local)
      @controller_ui.createButton(p2, func_build_road_collector, img_build_road_collector)
      @controller_ui.createButton(p2, func_build_road_artery,    img_build_road_artery)
       */
    };

    return UI;

  })(BSS.Element);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Written by Bryce Summers on Mar.21.2018
Has the camera follow an agent.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.Keyboard_ControlPlayer = (function(superClass) {
    extend(Keyboard_ControlPlayer, superClass);

    function Keyboard_ControlPlayer(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      this.up_pressed = false;
      this.left_pressed = false;
      this.right_pressed = false;
      this.down_pressed = false;
    }

    Keyboard_ControlPlayer.prototype.key_down = function(event) {
      var agent, agent_model;
      console.log(event.key);
      if (!this.up_pressed && event.key === "ArrowUp") {
        agent = this.scene.getFocusAgent();
        agent_model = agent.getModel();
        agent_model.setKey("psychology", "up");
      }
      if (!this.left_pressed && event.key === "ArrowLeft") {
        agent = this.scene.getFocusAgent();
        agent_model = agent.getModel();
        agent_model.setKey("psychology", "left");
      }
      if (!this.right_pressed && event.key === "ArrowRight") {
        agent = this.scene.getFocusAgent();
        agent_model = agent.getModel();
        agent_model.setKey("psychology", "right");
      }
      if (!this.down_pressed && event.key === "ArrowDown") {
        agent = this.scene.getFocusAgent();
        agent_model = agent.getModel();
        return agent_model.setKey("psychology", "down");
      }
    };

    Keyboard_ControlPlayer.prototype.key_up = function(event) {
      var up_pressed;
      if (event.key === "ArrowUp") {
        return up_pressed = false;
      }
    };

    Keyboard_ControlPlayer.prototype.time = function(dt) {};

    Keyboard_ControlPlayer.prototype.isIdle = function() {
      return true;
    };

    Keyboard_ControlPlayer.prototype.finish = function() {};

    return Keyboard_ControlPlayer;

  })(EX.I_Tool_Controller);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Written by Bryce Summers on Mar.21.2018
Has the camera follow an agent.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.TimeTool_CameraFollowsAgent = (function(superClass) {
    extend(TimeTool_CameraFollowsAgent, superClass);

    function TimeTool_CameraFollowsAgent(scene, camera) {
      this.scene = scene;
      this.camera = camera;
    }

    TimeTool_CameraFollowsAgent.prototype.time = function(dt) {
      var agent, agent_model, camera_model, place, place_model, ref, target_loc, target_up;
      agent = this.scene.getFocusAgent();
      place = this.scene.getFocusPlace();
      if (agent === null || place === null) {
        return;
      }
      agent_model = agent.getModel();
      place_model = place.getModel();
      camera_model = place_model.getCamera();
      if (camera_model === null) {
        return;
      }
      ref = agent_model.getCurrentLocationAndHeading(), target_loc = ref[0], target_up = ref[1];
      camera_model.setCenter(target_loc);
      camera_model.setUpDirection(target_up);
      return camera_model.applyInverseToObj(this.scene.getPivot(), this.scene.getView(), this.camera);
    };

    TimeTool_CameraFollowsAgent.prototype.isIdle = function() {
      return true;
    };

    TimeTool_CameraFollowsAgent.prototype.finish = function() {};

    return TimeTool_CameraFollowsAgent;

  })(EX.I_Tool_Controller);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Written by Bryce Summers on Mar.21.2018
Updates the scene's ui based on the statistics of the focus agent.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.TimeTool_DisplayFocusAgentStatistics = (function(superClass) {
    extend(TimeTool_DisplayFocusAgentStatistics, superClass);

    function TimeTool_DisplayFocusAgentStatistics(scene, camera) {
      this.scene = scene;
      this.camera = camera;
    }

    TimeTool_DisplayFocusAgentStatistics.prototype.time = function(dt) {
      var focus_agent, foodbox, ref, statistics, textbox, ui, ui_elements;
      focus_agent = this.scene.getFocusAgent();
      if (focus_agent === null) {
        return;
      }
      ref = this.scene.getUI(), ui = ref[0], ui_elements = ref[1];
      statistics = focus_agent.getModel().getStatistics();
      if (statistics.foodChanged()) {
        foodbox = ui_elements.foodbox;
        foodbox.str = EX.style.resource_name_food + statistics.getFood();
        ui.updateLabel(foodbox, {
          update_str: true
        });
      }
      if (statistics.narrativeChanged()) {
        textbox = ui_elements.textbox;
        textbox.str = statistics.getNarrative();
        return ui.updateLabel(textbox, {
          update_str: true
        });
      }
    };

    TimeTool_DisplayFocusAgentStatistics.prototype.isIdle = function() {
      return true;
    };

    TimeTool_DisplayFocusAgentStatistics.prototype.finish = function() {};

    return TimeTool_DisplayFocusAgentStatistics;

  })(EX.I_Tool_Controller);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Written by Bryce Summers on Mar.21.2018
Sends time update commands to all of the places.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.TimeTool_SceneTimer = (function(superClass) {
    extend(TimeTool_SceneTimer, superClass);

    function TimeTool_SceneTimer(scene, camera) {
      this.scene = scene;
      this.camera = camera;
    }

    TimeTool_SceneTimer.prototype.time = function(dt) {
      dt = dt / 1000;
      return this.scene.time(dt);
    };

    TimeTool_SceneTimer.prototype.isIdle = function() {
      return true;
    };

    TimeTool_SceneTimer.prototype.finish = function() {};

    return TimeTool_SceneTimer;

  })(EX.I_Tool_Controller);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Circle Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit circle that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.Mesh_Unit_Circle = (function(superClass) {
    extend(Mesh_Unit_Circle, superClass);

    function Mesh_Unit_Circle() {
      var geometry, outline, radius, segments, theata0, theata1;
      radius = .5;
      segments = 25;
      theata0 = 0;
      theata1 = Math.PI * 2;
      geometry = new THREE.CircleGeometry(radius, 25, theata0, theata1);
      outline = new THREE.Geometry();

      /*
      outline.vertices.push(
          new THREE.Vector3( -.5, -.5, 0 ),
          new THREE.Vector3(  .5, -.5, 0 ),
          new THREE.Vector3(  .5,  .5, 0 ),
          new THREE.Vector3( -.5,  .5, 0 ),
          new THREE.Vector3( -.5, -.5, 0 ) # Closed.
      )
       */
      Mesh_Unit_Circle.__super__.constructor.call(this, geometry, outline);
    }

    return Mesh_Unit_Circle;

  })(EX.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Square Mesh.

    Initializes as a unit square at the origin.

    Written by Bryce Summers on 11/22/2016.
    
    Purpose:
     - Provides a unit square that can then be scaled, positioned, and rotated.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.Mesh_Unit_Square = (function(superClass) {
    extend(Mesh_Unit_Square, superClass);

    function Mesh_Unit_Square() {
      var geometry, outline;
      geometry = new THREE.PlaneGeometry(1, 1);
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(-.5, -.5, 0), new THREE.Vector3(.5, -.5, 0), new THREE.Vector3(.5, .5, 0), new THREE.Vector3(-.5, .5, 0), new THREE.Vector3(-.5, -.5, 0));
      Mesh_Unit_Square.__super__.constructor.call(this, geometry, outline);
    }


    /*
    setup_texture_coordinates: () ->
        @geometry.faceVertexUvs.push(uv_coords)
    
        s = 1
    
        v1 = new THREE.Vector2(0, 0)
        v2 = new THREE.Vector2(s, 0)
        v3 = new THREE.Vector2(s, s)
        v4 = new THREE.Vector2(0, s)
    
        uv_coords.push([v1, v2, v3])
        uv_coords.push([v1, v3, v4])
    
        @geometry.uvsNeedUpdate = true
    
        @geometry.computeBoundingSphere()
    
        @geometry.computeFaceNormals()
        @geometry.computeVertexNormals()
        
        @geometry.verticesNeedUpdate = true
                
         * Changes to Vertex normals.
        @geometry.normalsNeedUpdate = true
        @geometry.colorsNeedUpdate = true
     */

    return Mesh_Unit_Square;

  })(EX.Mesh_Basic);

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
    Triangle Mesh.

    Description:
     - Provides a Triangle Pointing in the positive x (-->) direction
     - Along the x axis it is of length 1.
     - Along the y axis it is of length 1, but centered

    Written by Bryce Summers on 11/22/2016.
    
    Purpose: Used for many things, including the tops of houses.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EX.Mesh_Unit_Triangle = (function(superClass) {
    extend(Mesh_Unit_Triangle, superClass);

    function Mesh_Unit_Triangle() {
      var interior, outline;
      outline = new THREE.Geometry();
      outline.vertices.push(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -.5, 0), new THREE.Vector3(0, +.5, 0), new THREE.Vector3(1, 0, 0));
      interior = outline.clone();
      interior.faces.push(new THREE.Face3(0, 1, 2));
      Mesh_Unit_Triangle.__super__.constructor.call(this, interior, outline);
    }

    return Mesh_Unit_Triangle;

  })(EX.Mesh_Basic);

}).call(this);

/*
 * Entry Point to demo.
 * Pipes THREE.js and browser IO to game.
 * Written by Bryce Summers on 11/22/2016
 * Refactored by Bryce on 10.23.2017
 */

var renderer;
var root_scene;
var root_camera;

var input;
var root_AABB;

function init()
{
    // run some Tests.
    new EX.Testing();

    // Initialize all of the global material, mesh constructor's, etc.
    EX.init_style();

    init_camera();

    // Initialize Demo through the scene node.
    root_scene = new BSS.Scene();
    
    // Renderer.
    var params = {
        antialias: true,
    };
    
    init_renderer(params);

    // Set Renderer background clear color.
    renderer.setClearColor( 0xD8C49E );

    // Starts up the input tree.
    init_input();

    new EX.Visual_Factory() // Instantiates static content for future static calls.
    
    // Initialize the initial game state using the test place.
    var place = new BSS.Test_Place(root_scene);
    root_scene.addPlace(place);
    root_scene.activatePlace(place); // Activate the place for camera updates.
    root_scene.setViewToPlace(place);
}

function init_camera()
{
    // Camera.
    //var dim = {x:0, y:0, w:window.innerWidth, h:innerHeight, padding:10};
    // Fixed reolution viewport.
    dim = {x:0, y:0, w:1200, h:800, padding:10};
   
    // I may want to change to a perspective camera if we want to start showing depth information.
    root_camera = new THREE.OrthographicCamera( dim.x - dim.w/2, dim.x + dim.w/2, dim.y - dim.h/2, dim.y + dim.h/2, 1, 1000 );
    root_camera.position.z = 4;

    var x = dim.x + dim.w/2;
    var y = dim.y + dim.h/2;
    root_camera.position.x = x;
    root_camera.position.y = y;

    root_camera.lookAt(new THREE.Vector3(x, y, 0))
}

function init_renderer(params)
{
    var container = document.getElementById( 'container' );
    renderer = new THREE.WebGLRenderer(params);
    renderer.setPixelRatio( dim.w / dim.h /*window.devicePixelRatio*/ );
    container.appendChild( renderer.domElement );
    // Set the render based on the size of the window.
    onWindowResize();
}

function init_input()
{
    // Initialize the root of the input specification tree.
    input = new EX.I_All_Main(root_scene, root_camera);

    // Provide the scene with a hook into the io tree.
    root_scene.setInputRoot(input);

    window.addEventListener( 'resize', onWindowResize, false);

    //window.addEventListener("keypress", onKeyPress);
    window.addEventListener("keydown", onKeyPress);

    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mouseup",   onMouseUp);

    // The current system time, used to correctly pass time deltas.
    TIMESTAMP = performance.now();

    // Initialize Time input.
    beginTime();

    TIME_ON = true;
}

function beginTime()
{
    TIMESTAMP = performance.now();
    TIME_ON   = true;
    timestep();
}

function timestep()
{
    if(TIME_ON)
    {
        requestAnimationFrame(timestep)
    }
    else
    {
        return;
    }

    time_new = performance.now()
    var dt = time_new - TIMESTAMP
    TIMESTAMP = time_new

    try
    {
        input.time(dt)
    }
    catch(err)
    { // Stop time on error.
        TIME_ON = false
        throw err
    }

}

// Events.
function onWindowResize( event )
{
    //renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setSize( dim.w, dim.h );
}

// FIXME: ReWire these input events.
function onKeyPress( event )
{
    // Key codes for event.which.
    var LEFT  = 37
    var RIGHT = 39
    input.key_down(event)
}

function onKeyUp( event )
{
    input.key_up(event)
}

function onMouseMove( event )
{
    input.mouse_move(translateEvent(event));
}

function onMouseDown( e )//event
{
    //http://stackoverflow.com/questions/2405771/is-right-click-a-javascript-event
    var isRightMB;
    e = e || window.event;

    if ("which" in e)  // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
        isRightMB = e.which == 3; 
    else if ("button" in e)  // IE, Opera 
        isRightMB = e.button == 2; 

    if(isRightMB)
        return

    input.mouse_down(translateEvent(e));
}

function onMouseUp( event )
{
    input.mouse_up(translateEvent(event));
}

function animate()
{
    requestAnimationFrame( animate );
    render();
}

function render()
{
    renderer.render(root_scene.getVisualRepresentation(), root_camera);
}

// Since we are using a fixed size screen, we will need to translate the events.
function translateEvent(event)
{
    return {x: event.x -= window.innerWidth/2 - dim.w/2,
            y: event.y/* -= window.innerHeight/2 - dim.h/2*/}
}

init();
animate();